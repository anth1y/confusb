'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCompilerHostFromProjectRoot = exports.createCompilerHostFromConfigFile = exports.createCompilerHostFromBabelRc = undefined;
exports.initializeGlobalHooks = initializeGlobalHooks;
exports.init = init;
exports.createCompilerHostFromConfiguration = createCompilerHostFromConfiguration;
exports.createCompilerHostFromBabelRcSync = createCompilerHostFromBabelRcSync;
exports.createCompilerHostFromConfigFileSync = createCompilerHostFromConfigFileSync;
exports.createCompilerHostFromProjectRootSync = createCompilerHostFromProjectRootSync;
exports.calculateDefaultCompileCacheDirectory = calculateDefaultCompileCacheDirectory;
exports.getDefaultConfiguration = getDefaultConfiguration;
exports.createCompilers = createCompilers;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _promise = require('./promise');

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _compilerHost = require('./compiler-host');

var _compilerHost2 = _interopRequireDefault(_compilerHost);

var _protocolHook = require('./protocol-hook');

var _requireHook = require('./require-hook');

var _requireHook2 = _interopRequireDefault(_requireHook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

var d = require('debug')('electron-compile:config-parser');

// NB: We intentionally delay-load this so that in production, you can create
// cache-only versions of these compilers
var allCompilerClasses = null;

function statSyncNoException(fsPath) {
  if ('statSyncNoException' in _fs2.default) {
    return _fs2.default.statSyncNoException(fsPath);
  }

  try {
    return _fs2.default.statSync(fsPath);
  } catch (e) {
    return null;
  }
}

/**
 * Initialize the global hooks (protocol hook for file:, node.js hook) 
 * independent of initializing the compiler. This method is usually called by
 * init instead of directly
 * 
 * @param {CompilerHost} compilerHost  The compiler host to use.
 *  
 */
function initializeGlobalHooks(compilerHost) {
  var globalVar = global || window;
  globalVar.globalCompilerHost = compilerHost;

  (0, _requireHook2.default)(compilerHost);

  if ('type' in process && process.type === 'browser') {
    var _require = require('electron');

    var app = _require.app;

    var protoify = function protoify() {
      (0, _protocolHook.initializeProtocolHook)(compilerHost);
    };
    if (app.isReady()) {
      protoify();
    } else {
      app.on('ready', protoify);
    }
  }
}

/**
 * Initialize electron-compile and set it up, either for development or 
 * production use. This is almost always the only method you need to use in order
 * to use electron-compile.
 *  
 * @param  {string} appRoot  The top-level directory for your application (i.e.
 *                           the one which has your package.json).
 *
 * @param  {string} mainModule  The module to require in, relative to the module
 *                              calling init, that will start your app. Write this 
 *                              as if you were writing a require call from here.
 *
 * @param  {bool} productionMode   If explicitly True/False, will set read-only
 *                                 mode to be disabled/enabled. If not, we'll
 *                                 guess based on the presence of a production
 *                                 cache.
 */
function init(appRoot, mainModule) {
  var productionMode = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var compilerHost = null;
  var cacheDir = _path2.default.join(appRoot, '.cache');

  if (productionMode === null) {
    productionMode = !!statSyncNoException(cacheDir);
  }

  if (productionMode) {
    // In read-only mode, we'll assume that everything is in `appRoot/.cache`
    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(cacheDir, appRoot);
  } else {
    compilerHost = createCompilerHostFromProjectRootSync(appRoot);
  }

  initializeGlobalHooks(compilerHost);
  require.main.require(mainModule);
}

/**
 * Creates a {@link CompilerHost} with the given information. This method is
 * usually called by {@link createCompilerHostFromProjectRoot}.
 *  
 * @private
 */
function createCompilerHostFromConfiguration(info) {
  var compilers = createCompilers();
  var rootCacheDir = info.rootCacheDir || calculateDefaultCompileCacheDirectory();

  d('Creating CompilerHost: ' + JSON.stringify(info) + ', rootCacheDir = ' + rootCacheDir);
  var fileChangeCache = new _fileChangeCache2.default(info.appRoot);
  var ret = new _compilerHost2.default(rootCacheDir, compilers, fileChangeCache, false, compilers['text/plain']);

  _lodash2.default.each(Object.keys(info.options || {}), function (x) {
    var opts = info.options[x];
    if (!(x in compilers)) {
      throw new Error('Found compiler settings for missing compiler: ' + x);
    }

    d('Setting options for ' + x + ': ' + JSON.stringify(opts));
    compilers[x].compilerOptions = opts;
  });

  // NB: It's super important that we guarantee that the configuration is saved
  // out, because we'll need to re-read it in the renderer process
  d('Created compiler host with options: ' + JSON.stringify(info));
  ret.saveConfigurationSync();
  return ret;
}

/**
 * Creates a compiler host from a .babelrc file. This method is usually called
 * from {@link createCompilerHostFromProjectRoot} instead of used directly.
 *  
 * @param  {string} file  The path to a .babelrc file
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */

var createCompilerHostFromBabelRc = exports.createCompilerHostFromBabelRc = function () {
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(file) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var info, ourEnv;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.t0 = JSON;
            _context.next = 3;
            return _promise.pfs.readFile(file, 'utf8');

          case 3:
            _context.t1 = _context.sent;
            info = _context.t0.parse.call(_context.t0, _context.t1);

            // package.json
            if ('babel' in info) {
              info = info.babel;
            }

            if ('env' in info) {
              ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';

              info = info.env[ourEnv];
            }

            // Are we still package.json (i.e. is there no babel info whatsoever?)

            if (!('name' in info && 'version' in info)) {
              _context.next = 9;
              break;
            }

            return _context.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: getDefaultConfiguration(),
              rootCacheDir: rootCacheDir
            }));

          case 9:
            return _context.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: {
                'application/javascript': info
              },
              rootCacheDir: rootCacheDir
            }));

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function createCompilerHostFromBabelRc(_x3) {
    return ref.apply(this, arguments);
  };
}();

/**
 * Creates a compiler host from a .compilerc file. This method is usually called
 * from {@link createCompilerHostFromProjectRoot} instead of used directly.
 *  
 * @param  {string} file  The path to a .compilerc file
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */

var createCompilerHostFromConfigFile = exports.createCompilerHostFromConfigFile = function () {
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(file) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    var info, _ourEnv;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = JSON;
            _context2.next = 3;
            return _promise.pfs.readFile(file, 'utf8');

          case 3:
            _context2.t1 = _context2.sent;
            info = _context2.t0.parse.call(_context2.t0, _context2.t1);

            if ('env' in info) {
              _ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';

              info = info.env[_ourEnv];
            }

            return _context2.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: info,
              rootCacheDir: rootCacheDir
            }));

          case 7:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function createCompilerHostFromConfigFile(_x5) {
    return ref.apply(this, arguments);
  };
}();

/**
 * Creates a configured {@link CompilerHost} instance from the project root 
 * directory. This method first searches for a .compilerc, then falls back to the
 * default locations for Babel configuration info. If neither are found, defaults
 * to standard settings
 *  
 * @param  {string} rootDir  The root application directory (i.e. the directory
 *                           that has the app's package.json)
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */

var createCompilerHostFromProjectRoot = exports.createCompilerHostFromProjectRoot = function () {
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(rootDir) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var compilerc, babelrc;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            compilerc = _path2.default.join(rootDir, '.compilerc');

            if (!statSyncNoException(compilerc)) {
              _context3.next = 6;
              break;
            }

            d('Found a .compilerc at ' + compilerc + ', using it');
            _context3.next = 5;
            return createCompilerHostFromConfigFile(compilerc, rootCacheDir);

          case 5:
            return _context3.abrupt('return', _context3.sent);

          case 6:
            babelrc = _path2.default.join(rootDir, '.babelrc');

            if (!statSyncNoException(babelrc)) {
              _context3.next = 12;
              break;
            }

            d('Found a .babelrc at ' + babelrc + ', using it');
            _context3.next = 11;
            return createCompilerHostFromBabelRc(babelrc, rootCacheDir);

          case 11:
            return _context3.abrupt('return', _context3.sent);

          case 12:

            d('Using package.json or default parameters at ' + rootDir);
            _context3.next = 15;
            return createCompilerHostFromBabelRc(_path2.default.join(rootDir, 'package.json'), rootCacheDir);

          case 15:
            return _context3.abrupt('return', _context3.sent);

          case 16:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function createCompilerHostFromProjectRoot(_x7) {
    return ref.apply(this, arguments);
  };
}();

function createCompilerHostFromBabelRcSync(file) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));

  // package.json
  if ('babel' in info) {
    info = info.babel;
  }

  if ('env' in info) {
    var _ourEnv2 = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';
    info = info.env[_ourEnv2];
  }

  // Are we still package.json (i.e. is there no babel info whatsoever?)
  if ('name' in info && 'version' in info) {
    return createCompilerHostFromConfiguration({
      appRoot: _path2.default.dirname(file),
      options: getDefaultConfiguration(),
      rootCacheDir: rootCacheDir
    });
  }

  return createCompilerHostFromConfiguration({
    appRoot: _path2.default.dirname(file),
    options: {
      'application/javascript': info
    },
    rootCacheDir: rootCacheDir
  });
}

function createCompilerHostFromConfigFileSync(file) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));

  if ('env' in info) {
    var _ourEnv3 = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';
    info = info.env[_ourEnv3];
  }

  return createCompilerHostFromConfiguration({
    appRoot: _path2.default.dirname(file),
    options: info,
    rootCacheDir: rootCacheDir
  });
}

function createCompilerHostFromProjectRootSync(rootDir) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var compilerc = _path2.default.join(rootDir, '.compilerc');
  if (statSyncNoException(compilerc)) {
    d('Found a .compilerc at ' + compilerc + ', using it');
    return createCompilerHostFromConfigFileSync(compilerc, rootCacheDir);
  }

  var babelrc = _path2.default.join(rootDir, '.babelrc');
  if (statSyncNoException(babelrc)) {
    d('Found a .babelrc at ' + babelrc + ', using it');
    return createCompilerHostFromBabelRcSync(babelrc, rootCacheDir);
  }

  d('Using package.json or default parameters at ' + rootDir);
  return createCompilerHostFromBabelRcSync(_path2.default.join(rootDir, 'package.json'), rootCacheDir);
}

/**
 * Returns what electron-compile would use as a default rootCacheDir. Usually only
 * used for debugging purposes
 *  
 * @return {string}  A path that may or may not exist where electron-compile would
 *                   set up a development mode cache.
 */
function calculateDefaultCompileCacheDirectory() {
  var tmpDir = process.env.TEMP || process.env.TMPDIR || '/tmp';
  var hash = require('crypto').createHash('md5').update(process.execPath).digest('hex');

  var cacheDir = _path2.default.join(tmpDir, 'compileCache_' + hash);
  _mkdirp2.default.sync(cacheDir);

  d('Using default cache directory: ' + cacheDir);
  return cacheDir;
}

/**
 * Returns the default .configrc if no configuration information can be found.
 *  
 * @return {Object}  A list of default config settings for electron-compiler.
 */
function getDefaultConfiguration() {
  return {
    'application/javascript': {
      "presets": ["stage-0", "es2015", "react"],
      "sourceMaps": "inline"
    }
  };
}

/**
 * Allows you to create new instances of all compilers that are supported by 
 * electron-compile and use them directly. Currently supports Babel, CoffeeScript, 
 * TypeScript, LESS, and Jade.
 *  
 * @return {Object}  An Object whose Keys are MIME types, and whose values 
 * are instances of @{link CompilerBase}.
 */
function createCompilers() {
  if (!allCompilerClasses) {
    // First we want to see if electron-compilers itself has been installed with
    // devDependencies. If that's not the case, check to see if
    // electron-compilers is installed as a peer dependency (probably as a
    // devDependency of the root project).
    var locations = ['electron-compilers', '../../electron-compilers'];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = locations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var location = _step.value;

        try {
          allCompilerClasses = require(location);
        } catch (e) {
          // Yolo
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!allCompilerClasses) {
      throw new Error("Electron compilers not found but were requested to be loaded");
    }
  }

  // NB: Note that this code is carefully set up so that InlineHtmlCompiler
  // (i.e. classes with `createFromCompilers`) initially get an empty object,
  // but will have a reference to the final result of what we return, which
  // resolves the circular dependency we'd otherwise have here.
  var ret = {};
  var instantiatedClasses = _lodash2.default.map(allCompilerClasses, function (Klass) {
    if ('createFromCompilers' in Klass) {
      return Klass.createFromCompilers(ret);
    } else {
      return new Klass();
    }
  });

  _lodash2.default.reduce(instantiatedClasses, function (acc, x) {
    var Klass = Object.getPrototypeOf(x).constructor;

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = Klass.getInputMimeTypes()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var type = _step2.value;
        acc[type] = x;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return acc;
  }, ret);

  return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25maWctcGFyc2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztRQXNDZ0I7UUFvQ0E7UUEwQkE7UUEySEE7UUErQkE7UUFlQTtRQXdCQTtRQWlCQTtRQWlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE1VGhCLElBQU0sSUFBSSxRQUFRLE9BQVIsRUFBaUIsZ0NBQWpCLENBQUo7Ozs7QUFJTixJQUFJLHFCQUFxQixJQUFyQjs7QUFFSixTQUFTLG1CQUFULENBQTZCLE1BQTdCLEVBQXFDO0FBQ25DLE1BQUkscUNBQUosRUFBaUM7QUFDL0IsV0FBTyxhQUFHLG1CQUFILENBQXVCLE1BQXZCLENBQVAsQ0FEK0I7R0FBakM7O0FBSUEsTUFBSTtBQUNGLFdBQU8sYUFBRyxRQUFILENBQVksTUFBWixDQUFQLENBREU7R0FBSixDQUVFLE9BQU8sQ0FBUCxFQUFVO0FBQ1YsV0FBTyxJQUFQLENBRFU7R0FBVjtDQVBKOzs7Ozs7Ozs7O0FBcUJPLFNBQVMscUJBQVQsQ0FBK0IsWUFBL0IsRUFBNkM7QUFDbEQsTUFBSSxZQUFhLFVBQVUsTUFBVixDQURpQztBQUVsRCxZQUFVLGtCQUFWLEdBQStCLFlBQS9CLENBRmtEOztBQUlsRCw2QkFBeUIsWUFBekIsRUFKa0Q7O0FBTWxELE1BQUksVUFBVSxPQUFWLElBQXFCLFFBQVEsSUFBUixLQUFpQixTQUFqQixFQUE0QjttQkFDbkMsUUFBUSxVQUFSLEVBRG1DOztRQUMzQyxtQkFEMkM7O0FBR25ELFFBQUksV0FBVyxTQUFYLFFBQVcsR0FBVztBQUFFLGdEQUF1QixZQUF2QixFQUFGO0tBQVgsQ0FIb0M7QUFJbkQsUUFBSSxJQUFJLE9BQUosRUFBSixFQUFtQjtBQUNqQixpQkFEaUI7S0FBbkIsTUFFTztBQUNMLFVBQUksRUFBSixDQUFPLE9BQVAsRUFBZ0IsUUFBaEIsRUFESztLQUZQO0dBSkY7Q0FOSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQSxTQUFTLElBQVQs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Ozs7Ozs7O0tBSHVDOztBQUl2QyxXQUFPLEdBQVAsQ0FKdUM7R0FBWCxFQUszQixHQUxILEVBbENnQzs7QUF5Q2hDLFNBQU8sR0FBUCxDQXpDZ0M7Q0FBM0IiLCJmaWxlIjoiY29uZmlnLXBhcnNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgbWtkaXJwIGZyb20gJ21rZGlycCc7XG5pbXBvcnQge3Bmc30gZnJvbSAnLi9wcm9taXNlJztcblxuaW1wb3J0IEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAnLi9maWxlLWNoYW5nZS1jYWNoZSc7XG5pbXBvcnQgQ29tcGlsZXJIb3N0IGZyb20gJy4vY29tcGlsZXItaG9zdCc7XG5pbXBvcnQgeyBpbml0aWFsaXplUHJvdG9jb2xIb29rIH0gZnJvbSAnLi9wcm90b2NvbC1ob29rJztcbmltcG9ydCByZWdpc3RlclJlcXVpcmVFeHRlbnNpb24gZnJvbSAnLi9yZXF1aXJlLWhvb2snO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpjb25maWctcGFyc2VyJyk7XG5cbi8vIE5COiBXZSBpbnRlbnRpb25hbGx5IGRlbGF5LWxvYWQgdGhpcyBzbyB0aGF0IGluIHByb2R1Y3Rpb24sIHlvdSBjYW4gY3JlYXRlXG4vLyBjYWNoZS1vbmx5IHZlcnNpb25zIG9mIHRoZXNlIGNvbXBpbGVyc1xubGV0IGFsbENvbXBpbGVyQ2xhc3NlcyA9IG51bGw7XG5cbmZ1bmN0aW9uIHN0YXRTeW5jTm9FeGNlcHRpb24oZnNQYXRoKSB7XG4gIGlmICgnc3RhdFN5bmNOb0V4Y2VwdGlvbicgaW4gZnMpIHtcbiAgICByZXR1cm4gZnMuc3RhdFN5bmNOb0V4Y2VwdGlvbihmc1BhdGgpO1xuICB9XG4gIFxuICB0cnkge1xuICAgIHJldHVybiBmcy5zdGF0U3luYyhmc1BhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGdsb2JhbCBob29rcyAocHJvdG9jb2wgaG9vayBmb3IgZmlsZTosIG5vZGUuanMgaG9vaykgXG4gKiBpbmRlcGVuZGVudCBvZiBpbml0aWFsaXppbmcgdGhlIGNvbXBpbGVyLiBUaGlzIG1ldGhvZCBpcyB1c3VhbGx5IGNhbGxlZCBieVxuICogaW5pdCBpbnN0ZWFkIG9mIGRpcmVjdGx5XG4gKiBcbiAqIEBwYXJhbSB7Q29tcGlsZXJIb3N0fSBjb21waWxlckhvc3QgIFRoZSBjb21waWxlciBob3N0IHRvIHVzZS5cbiAqICBcbiAqLyBcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0KSB7XG4gIGxldCBnbG9iYWxWYXIgPSAoZ2xvYmFsIHx8IHdpbmRvdyk7XG4gIGdsb2JhbFZhci5nbG9iYWxDb21waWxlckhvc3QgPSBjb21waWxlckhvc3Q7XG5cbiAgcmVnaXN0ZXJSZXF1aXJlRXh0ZW5zaW9uKGNvbXBpbGVySG9zdCk7XG5cbiAgaWYgKCd0eXBlJyBpbiBwcm9jZXNzICYmIHByb2Nlc3MudHlwZSA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgY29uc3QgeyBhcHAgfSA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XG4gICAgXG4gICAgbGV0IHByb3RvaWZ5ID0gZnVuY3Rpb24oKSB7IGluaXRpYWxpemVQcm90b2NvbEhvb2soY29tcGlsZXJIb3N0KTsgfTtcbiAgICBpZiAoYXBwLmlzUmVhZHkoKSkge1xuICAgICAgcHJvdG9pZnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwLm9uKCdyZWFkeScsIHByb3RvaWZ5KTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEluaXRpYWxpemUgZWxlY3Ryb24tY29tcGlsZSBhbmQgc2V0IGl0IHVwLCBlaXRoZXIgZm9yIGRldmVsb3BtZW50IG9yIFxuICogcHJvZHVjdGlvbiB1c2UuIFRoaXMgaXMgYWxtb3N0IGFsd2F5cyB0aGUgb25seSBtZXRob2QgeW91IG5lZWQgdG8gdXNlIGluIG9yZGVyXG4gKiB0byB1c2UgZWxlY3Ryb24tY29tcGlsZS5cbiAqICBcbiAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbWFpbk1vZHVsZSAgVGhlIG1vZHVsZSB0byByZXF1aXJlIGluLCByZWxhdGl2ZSB0byB0aGUgbW9kdWxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxpbmcgaW5pdCwgdGhhdCB3aWxsIHN0YXJ0IHlvdXIgYXBwLiBXcml0ZSB0aGlzIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBpZiB5b3Ugd2VyZSB3cml0aW5nIGEgcmVxdWlyZSBjYWxsIGZyb20gaGVyZS5cbiAqXG4gKiBAcGFyYW0gIHtib29sfSBwcm9kdWN0aW9uTW9kZSAgIElmIGV4cGxpY2l0bHkgVHJ1ZS9GYWxzZSwgd2lsbCBzZXQgcmVhZC1vbmx5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgdG8gYmUgZGlzYWJsZWQvZW5hYmxlZC4gSWYgbm90LCB3ZSdsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWVzcyBiYXNlZCBvbiB0aGUgcHJlc2VuY2Ugb2YgYSBwcm9kdWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLlxuICovIFxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoYXBwUm9vdCwgbWFpbk1vZHVsZSwgcHJvZHVjdGlvbk1vZGUgPSBudWxsKSB7XG4gIGxldCBjb21waWxlckhvc3QgPSBudWxsO1xuICBsZXQgY2FjaGVEaXIgPSBwYXRoLmpvaW4oYXBwUm9vdCwgJy5jYWNoZScpO1xuICBcbiAgaWYgKHByb2R1Y3Rpb25Nb2RlID09PSBudWxsKSB7XG4gICAgcHJvZHVjdGlvbk1vZGUgPSAhIXN0YXRTeW5jTm9FeGNlcHRpb24oY2FjaGVEaXIpO1xuICB9XG4gIFxuICBpZiAocHJvZHVjdGlvbk1vZGUpIHtcbiAgICAvLyBJbiByZWFkLW9ubHkgbW9kZSwgd2UnbGwgYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpcyBpbiBgYXBwUm9vdC8uY2FjaGVgXG4gICAgY29tcGlsZXJIb3N0ID0gQ29tcGlsZXJIb3N0LmNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKGNhY2hlRGlyLCBhcHBSb290KTtcbiAgfSBlbHNlIHtcbiAgICBjb21waWxlckhvc3QgPSBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKGFwcFJvb3QpO1xuICB9XG4gIFxuICBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0KTtcbiAgcmVxdWlyZS5tYWluLnJlcXVpcmUobWFpbk1vZHVsZSk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIENvbXBpbGVySG9zdH0gd2l0aCB0aGUgZ2l2ZW4gaW5mb3JtYXRpb24uIFRoaXMgbWV0aG9kIGlzXG4gKiB1c3VhbGx5IGNhbGxlZCBieSB7QGxpbmsgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290fS5cbiAqICBcbiAqIEBwcml2YXRlXG4gKi8gXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oaW5mbykge1xuICBsZXQgY29tcGlsZXJzID0gY3JlYXRlQ29tcGlsZXJzKCk7XG4gIGxldCByb290Q2FjaGVEaXIgPSBpbmZvLnJvb3RDYWNoZURpciB8fCBjYWxjdWxhdGVEZWZhdWx0Q29tcGlsZUNhY2hlRGlyZWN0b3J5KCk7XG4gIFxuICBkKGBDcmVhdGluZyBDb21waWxlckhvc3Q6ICR7SlNPTi5zdHJpbmdpZnkoaW5mbyl9LCByb290Q2FjaGVEaXIgPSAke3Jvb3RDYWNoZURpcn1gKTtcbiAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IG5ldyBGaWxlQ2hhbmdlZENhY2hlKGluZm8uYXBwUm9vdCk7XG4gIGxldCByZXQgPSBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBjb21waWxlcnNbJ3RleHQvcGxhaW4nXSk7XG4gIFxuICBfLmVhY2goT2JqZWN0LmtleXMoaW5mby5vcHRpb25zIHx8IHt9KSwgKHgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGluZm8ub3B0aW9uc1t4XTtcbiAgICBpZiAoISh4IGluIGNvbXBpbGVycykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgY29tcGlsZXIgc2V0dGluZ3MgZm9yIG1pc3NpbmcgY29tcGlsZXI6ICR7eH1gKTtcbiAgICB9XG4gICAgXG4gICAgZChgU2V0dGluZyBvcHRpb25zIGZvciAke3h9OiAke0pTT04uc3RyaW5naWZ5KG9wdHMpfWApO1xuICAgIGNvbXBpbGVyc1t4XS5jb21waWxlck9wdGlvbnMgPSBvcHRzO1xuICB9KTtcbiAgXG4gIC8vIE5COiBJdCdzIHN1cGVyIGltcG9ydGFudCB0aGF0IHdlIGd1YXJhbnRlZSB0aGF0IHRoZSBjb25maWd1cmF0aW9uIGlzIHNhdmVkXG4gIC8vIG91dCwgYmVjYXVzZSB3ZSdsbCBuZWVkIHRvIHJlLXJlYWQgaXQgaW4gdGhlIHJlbmRlcmVyIHByb2Nlc3NcbiAgZChgQ3JlYXRlZCBjb21waWxlciBob3N0IHdpdGggb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShpbmZvKX1gKTtcbiAgcmV0LnNhdmVDb25maWd1cmF0aW9uU3luYygpO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21waWxlciBob3N0IGZyb20gYSAuYmFiZWxyYyBmaWxlLiBUaGlzIG1ldGhvZCBpcyB1c3VhbGx5IGNhbGxlZFxuICogZnJvbSB7QGxpbmsgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290fSBpbnN0ZWFkIG9mIHVzZWQgZGlyZWN0bHkuXG4gKiAgXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGUgIFRoZSBwYXRoIHRvIGEgLmJhYmVscmMgZmlsZVxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gcm9vdENhY2hlRGlyIChvcHRpb25hbCkgIFRoZSBkaXJlY3RvcnkgdG8gdXNlIGFzIGEgY2FjaGUuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSBzZXQtdXAgY29tcGlsZXIgaG9zdFxuICovIFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsKSB7XG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwZnMucmVhZEZpbGUoZmlsZSwgJ3V0ZjgnKSk7XG4gIFxuICAvLyBwYWNrYWdlLmpzb25cbiAgaWYgKCdiYWJlbCcgaW4gaW5mbykge1xuICAgIGluZm8gPSBpbmZvLmJhYmVsO1xuICB9XG4gIFxuICBpZiAoJ2VudicgaW4gaW5mbykge1xuICAgIGxldCBvdXJFbnYgPSBwcm9jZXNzLmVudi5CQUJFTF9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcbiAgfVxuICBcbiAgLy8gQXJlIHdlIHN0aWxsIHBhY2thZ2UuanNvbiAoaS5lLiBpcyB0aGVyZSBubyBiYWJlbCBpbmZvIHdoYXRzb2V2ZXI/KVxuICBpZiAoJ25hbWUnIGluIGluZm8gJiYgJ3ZlcnNpb24nIGluIGluZm8pIHtcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xuICAgICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxuICAgICAgb3B0aW9uczogZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKSxcbiAgICAgIHJvb3RDYWNoZURpclxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IGluZm9cbiAgICB9LFxuICAgIHJvb3RDYWNoZURpclxuICB9KTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21waWxlciBob3N0IGZyb20gYSAuY29tcGlsZXJjIGZpbGUuIFRoaXMgbWV0aG9kIGlzIHVzdWFsbHkgY2FsbGVkXG4gKiBmcm9tIHtAbGluayBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3R9IGluc3RlYWQgb2YgdXNlZCBkaXJlY3RseS5cbiAqICBcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgVGhlIHBhdGggdG8gYSAuY29tcGlsZXJjIGZpbGVcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAob3B0aW9uYWwpICBUaGUgZGlyZWN0b3J5IHRvIHVzZSBhcyBhIGNhY2hlLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgc2V0LXVwIGNvbXBpbGVyIGhvc3RcbiAqLyBcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZShmaWxlLCByb290Q2FjaGVEaXI9bnVsbCkge1xuICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGUsICd1dGY4JykpO1xuICBcbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuRUxFQ1RST05fQ09NUElMRV9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcbiAgfVxuICBcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcbiAgICBhcHBSb290OiBwYXRoLmRpcm5hbWUoZmlsZSksXG4gICAgb3B0aW9uczogaW5mbyxcbiAgICByb290Q2FjaGVEaXJcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZmlndXJlZCB7QGxpbmsgQ29tcGlsZXJIb3N0fSBpbnN0YW5jZSBmcm9tIHRoZSBwcm9qZWN0IHJvb3QgXG4gKiBkaXJlY3RvcnkuIFRoaXMgbWV0aG9kIGZpcnN0IHNlYXJjaGVzIGZvciBhIC5jb21waWxlcmMsIHRoZW4gZmFsbHMgYmFjayB0byB0aGVcbiAqIGRlZmF1bHQgbG9jYXRpb25zIGZvciBCYWJlbCBjb25maWd1cmF0aW9uIGluZm8uIElmIG5laXRoZXIgYXJlIGZvdW5kLCBkZWZhdWx0c1xuICogdG8gc3RhbmRhcmQgc2V0dGluZ3NcbiAqICBcbiAqIEBwYXJhbSAge3N0cmluZ30gcm9vdERpciAgVGhlIHJvb3QgYXBwbGljYXRpb24gZGlyZWN0b3J5IChpLmUuIHRoZSBkaXJlY3RvcnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBoYXMgdGhlIGFwcCdzIHBhY2thZ2UuanNvbilcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAob3B0aW9uYWwpICBUaGUgZGlyZWN0b3J5IHRvIHVzZSBhcyBhIGNhY2hlLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgc2V0LXVwIGNvbXBpbGVyIGhvc3RcbiAqLyBcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3Qocm9vdERpciwgcm9vdENhY2hlRGlyPW51bGwpIHtcbiAgbGV0IGNvbXBpbGVyYyA9IHBhdGguam9pbihyb290RGlyLCAnLmNvbXBpbGVyYycpO1xuICBpZiAoc3RhdFN5bmNOb0V4Y2VwdGlvbihjb21waWxlcmMpKSB7XG4gICAgZChgRm91bmQgYSAuY29tcGlsZXJjIGF0ICR7Y29tcGlsZXJjfSwgdXNpbmcgaXRgKTtcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGUoY29tcGlsZXJjLCByb290Q2FjaGVEaXIpO1xuICB9XG4gIFxuICBsZXQgYmFiZWxyYyA9IHBhdGguam9pbihyb290RGlyLCAnLmJhYmVscmMnKTtcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oYmFiZWxyYykpIHtcbiAgICBkKGBGb3VuZCBhIC5iYWJlbHJjIGF0ICR7YmFiZWxyY30sIHVzaW5nIGl0YCk7XG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjKGJhYmVscmMsIHJvb3RDYWNoZURpcik7XG4gIH1cbiAgICBcbiAgZChgVXNpbmcgcGFja2FnZS5qc29uIG9yIGRlZmF1bHQgcGFyYW1ldGVycyBhdCAke3Jvb3REaXJ9YCk7XG4gIHJldHVybiBhd2FpdCBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSYyhwYXRoLmpvaW4ocm9vdERpciwgJ3BhY2thZ2UuanNvbicpLCByb290Q2FjaGVEaXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsKSB7XG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKSk7XG4gIFxuICAvLyBwYWNrYWdlLmpzb25cbiAgaWYgKCdiYWJlbCcgaW4gaW5mbykge1xuICAgIGluZm8gPSBpbmZvLmJhYmVsO1xuICB9XG4gIFxuICBpZiAoJ2VudicgaW4gaW5mbykge1xuICAgIGxldCBvdXJFbnYgPSBwcm9jZXNzLmVudi5CQUJFTF9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcbiAgfVxuICBcbiAgLy8gQXJlIHdlIHN0aWxsIHBhY2thZ2UuanNvbiAoaS5lLiBpcyB0aGVyZSBubyBiYWJlbCBpbmZvIHdoYXRzb2V2ZXI/KVxuICBpZiAoJ25hbWUnIGluIGluZm8gJiYgJ3ZlcnNpb24nIGluIGluZm8pIHtcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xuICAgICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxuICAgICAgb3B0aW9uczogZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKSxcbiAgICAgIHJvb3RDYWNoZURpclxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IGluZm9cbiAgICB9LFxuICAgIHJvb3RDYWNoZURpclxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlU3luYyhmaWxlLCByb290Q2FjaGVEaXI9bnVsbCkge1xuICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGZpbGUsICd1dGY4JykpO1xuICBcbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuRUxFQ1RST05fQ09NUElMRV9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcbiAgfVxuICBcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcbiAgICBhcHBSb290OiBwYXRoLmRpcm5hbWUoZmlsZSksXG4gICAgb3B0aW9uczogaW5mbyxcbiAgICByb290Q2FjaGVEaXJcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKHJvb3REaXIsIHJvb3RDYWNoZURpcj1udWxsKSB7XG4gIGxldCBjb21waWxlcmMgPSBwYXRoLmpvaW4ocm9vdERpciwgJy5jb21waWxlcmMnKTtcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oY29tcGlsZXJjKSkge1xuICAgIGQoYEZvdW5kIGEgLmNvbXBpbGVyYyBhdCAke2NvbXBpbGVyY30sIHVzaW5nIGl0YCk7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlU3luYyhjb21waWxlcmMsIHJvb3RDYWNoZURpcik7XG4gIH1cbiAgXG4gIGxldCBiYWJlbHJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuYmFiZWxyYycpO1xuICBpZiAoc3RhdFN5bmNOb0V4Y2VwdGlvbihiYWJlbHJjKSkge1xuICAgIGQoYEZvdW5kIGEgLmJhYmVscmMgYXQgJHtiYWJlbHJjfSwgdXNpbmcgaXRgKTtcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jKGJhYmVscmMsIHJvb3RDYWNoZURpcik7XG4gIH1cbiAgICBcbiAgZChgVXNpbmcgcGFja2FnZS5qc29uIG9yIGRlZmF1bHQgcGFyYW1ldGVycyBhdCAke3Jvb3REaXJ9YCk7XG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSY1N5bmMocGF0aC5qb2luKHJvb3REaXIsICdwYWNrYWdlLmpzb24nKSwgcm9vdENhY2hlRGlyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoYXQgZWxlY3Ryb24tY29tcGlsZSB3b3VsZCB1c2UgYXMgYSBkZWZhdWx0IHJvb3RDYWNoZURpci4gVXN1YWxseSBvbmx5XG4gKiB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAqICBcbiAqIEByZXR1cm4ge3N0cmluZ30gIEEgcGF0aCB0aGF0IG1heSBvciBtYXkgbm90IGV4aXN0IHdoZXJlIGVsZWN0cm9uLWNvbXBpbGUgd291bGRcbiAqICAgICAgICAgICAgICAgICAgIHNldCB1cCBhIGRldmVsb3BtZW50IG1vZGUgY2FjaGUuXG4gKi8gXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGVmYXVsdENvbXBpbGVDYWNoZURpcmVjdG9yeSgpIHtcbiAgbGV0IHRtcERpciA9IHByb2Nlc3MuZW52LlRFTVAgfHwgcHJvY2Vzcy5lbnYuVE1QRElSIHx8ICcvdG1wJztcbiAgbGV0IGhhc2ggPSByZXF1aXJlKCdjcnlwdG8nKS5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUocHJvY2Vzcy5leGVjUGF0aCkuZGlnZXN0KCdoZXgnKTtcblxuICBsZXQgY2FjaGVEaXIgPSBwYXRoLmpvaW4odG1wRGlyLCBgY29tcGlsZUNhY2hlXyR7aGFzaH1gKTtcbiAgbWtkaXJwLnN5bmMoY2FjaGVEaXIpO1xuICBcbiAgZChgVXNpbmcgZGVmYXVsdCBjYWNoZSBkaXJlY3Rvcnk6ICR7Y2FjaGVEaXJ9YCk7XG4gIHJldHVybiBjYWNoZURpcjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgLmNvbmZpZ3JjIGlmIG5vIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kLlxuICogIFxuICogQHJldHVybiB7T2JqZWN0fSAgQSBsaXN0IG9mIGRlZmF1bHQgY29uZmlnIHNldHRpbmdzIGZvciBlbGVjdHJvbi1jb21waWxlci5cbiAqLyBcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlndXJhdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IHtcbiAgICAgIFwicHJlc2V0c1wiOiBbXCJzdGFnZS0wXCIsIFwiZXMyMDE1XCIsIFwicmVhY3RcIl0sXG4gICAgICBcInNvdXJjZU1hcHNcIjogXCJpbmxpbmVcIlxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIGFsbCBjb21waWxlcnMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IFxuICogZWxlY3Ryb24tY29tcGlsZSBhbmQgdXNlIHRoZW0gZGlyZWN0bHkuIEN1cnJlbnRseSBzdXBwb3J0cyBCYWJlbCwgQ29mZmVlU2NyaXB0LCBcbiAqIFR5cGVTY3JpcHQsIExFU1MsIGFuZCBKYWRlLlxuICogIFxuICogQHJldHVybiB7T2JqZWN0fSAgQW4gT2JqZWN0IHdob3NlIEtleXMgYXJlIE1JTUUgdHlwZXMsIGFuZCB3aG9zZSB2YWx1ZXMgXG4gKiBhcmUgaW5zdGFuY2VzIG9mIEB7bGluayBDb21waWxlckJhc2V9LlxuICovIFxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVycygpIHtcbiAgaWYgKCFhbGxDb21waWxlckNsYXNzZXMpIHtcbiAgICAvLyBGaXJzdCB3ZSB3YW50IHRvIHNlZSBpZiBlbGVjdHJvbi1jb21waWxlcnMgaXRzZWxmIGhhcyBiZWVuIGluc3RhbGxlZCB3aXRoXG4gICAgLy8gZGV2RGVwZW5kZW5jaWVzLiBJZiB0aGF0J3Mgbm90IHRoZSBjYXNlLCBjaGVjayB0byBzZWUgaWZcbiAgICAvLyBlbGVjdHJvbi1jb21waWxlcnMgaXMgaW5zdGFsbGVkIGFzIGEgcGVlciBkZXBlbmRlbmN5IChwcm9iYWJseSBhcyBhXG4gICAgLy8gZGV2RGVwZW5kZW5jeSBvZiB0aGUgcm9vdCBwcm9qZWN0KS5cbiAgICBjb25zdCBsb2NhdGlvbnMgPSBbJ2VsZWN0cm9uLWNvbXBpbGVycycsICcuLi8uLi9lbGVjdHJvbi1jb21waWxlcnMnXTtcblxuICAgIGZvciAobGV0IGxvY2F0aW9uIG9mIGxvY2F0aW9ucykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWxsQ29tcGlsZXJDbGFzc2VzID0gcmVxdWlyZShsb2NhdGlvbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFlvbG9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFsbENvbXBpbGVyQ2xhc3Nlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlY3Ryb24gY29tcGlsZXJzIG5vdCBmb3VuZCBidXQgd2VyZSByZXF1ZXN0ZWQgdG8gYmUgbG9hZGVkXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE5COiBOb3RlIHRoYXQgdGhpcyBjb2RlIGlzIGNhcmVmdWxseSBzZXQgdXAgc28gdGhhdCBJbmxpbmVIdG1sQ29tcGlsZXIgXG4gIC8vIChpLmUuIGNsYXNzZXMgd2l0aCBgY3JlYXRlRnJvbUNvbXBpbGVyc2ApIGluaXRpYWxseSBnZXQgYW4gZW1wdHkgb2JqZWN0LFxuICAvLyBidXQgd2lsbCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2Ygd2hhdCB3ZSByZXR1cm4sIHdoaWNoXG4gIC8vIHJlc29sdmVzIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5IHdlJ2Qgb3RoZXJ3aXNlIGhhdmUgaGVyZS5cbiAgbGV0IHJldCA9IHt9O1xuICBsZXQgaW5zdGFudGlhdGVkQ2xhc3NlcyA9IF8ubWFwKGFsbENvbXBpbGVyQ2xhc3NlcywgKEtsYXNzKSA9PiB7XG4gICAgaWYgKCdjcmVhdGVGcm9tQ29tcGlsZXJzJyBpbiBLbGFzcykge1xuICAgICAgcmV0dXJuIEtsYXNzLmNyZWF0ZUZyb21Db21waWxlcnMocmV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBLbGFzcygpO1xuICAgIH1cbiAgfSk7XG5cbiAgXy5yZWR1Y2UoaW5zdGFudGlhdGVkQ2xhc3NlcywgKGFjYyx4KSA9PiB7XG4gICAgbGV0IEtsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLmNvbnN0cnVjdG9yO1xuXG4gICAgZm9yIChsZXQgdHlwZSBvZiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpKSB7IGFjY1t0eXBlXSA9IHg7IH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCByZXQpO1xuICBcbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==