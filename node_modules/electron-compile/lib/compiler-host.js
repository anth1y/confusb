'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _mimeTypes = require('mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _promise = require('./promise');

var _forAllFiles = require('./for-all-files');

var _compileCache = require('./compile-cache');

var _compileCache2 = _interopRequireDefault(_compileCache);

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _readOnlyCompiler = require('./read-only-compiler');

var _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var d = require('debug')('electron-compile:compiler-host');

// This isn't even my
var finalForms = {
  'text/javascript': true,
  'application/javascript': true,
  'text/html': true,
  'text/css': true,
  'image/svg+xml': true,
  'application/json': true
};

/**
 * This class is the top-level class that encapsulates all of the logic of 
 * compiling and caching application code. If you're looking for a "Main class",
 * this is it.
 * 
 * This class can be created directly but it is usually created via the methods
 * in config-parser, which will among other things, set up the compiler options
 * given a project root.
 * 
 * CompilerHost is also the top-level class that knows how to serialize all of the
 * information necessary to recreate itself, either as a development host (i.e.
 * will allow cache misses and actual compilation), or as a read-only version of
 * itself for production.
 */

var CompilerHost = function () {
  /**  
   * Creates an instance of CompilerHost. You probably want to use the methods
   * in config-parser for development, or {@link createReadonlyFromConfiguration}
   * for production instead.
   *    
   * @param  {string} rootCacheDir  The root directory to use for the cache
   * 
   * @param  {Object} compilers  an Object whose keys are input MIME types and
   *                             whose values are instances of CompilerBase. Create
   *                             this via the {@link createCompilers} method in
   *                             config-parser.
   * 
   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is 
   *                                             optionally pre-loaded.
   * 
   * @param  {boolean} readOnlyMode  If True, cache misses will fail and 
   *                                 compilation will not be attempted.
   * 
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   */

  function CompilerHost(rootCacheDir, compilers, fileChangeCache, readOnlyMode) {
    var fallbackCompiler = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];

    _classCallCheck(this, CompilerHost);

    var compilersByMimeType = _lodash2.default.assign({}, compilers);
    _lodash2.default.assign(this, { rootCacheDir: rootCacheDir, compilersByMimeType: compilersByMimeType, fileChangeCache: fileChangeCache, readOnlyMode: readOnlyMode, fallbackCompiler: fallbackCompiler });
    this.appRoot = this.fileChangeCache.appRoot;

    this.cachesForCompilers = _lodash2.default.reduce(Object.keys(compilersByMimeType), function (acc, x) {
      var compiler = compilersByMimeType[x];
      if (acc.has(compiler)) return acc;

      acc.set(compiler, _compileCache2.default.createFromCompiler(rootCacheDir, compiler, fileChangeCache, readOnlyMode));
      return acc;
    }, new Map());
  }

  /**    
   * Creates a production-mode CompilerHost from the previously saved 
   * configuration
   *    
   * @param  {string} rootCacheDir  The root directory to use for the cache. This
   *                                cache must have cache information saved via
   *                                {@link saveConfiguration}
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present. 
   *
   * @return {Promise<CompilerHost>}  A read-only CompilerHost
   */

  _createClass(CompilerHost, [{
    key: 'saveConfiguration',

    /**  
     * Saves the current compiler configuration to a file that 
     * {@link createReadonlyFromConfiguration} can use to recreate the current 
     * compiler environment
     *    
     * @return {Promise}  Completion
     */
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var serializedCompilerOpts, info, target, buf;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                serializedCompilerOpts = _lodash2.default.reduce(Object.keys(this.compilersByMimeType), function (acc, x) {
                  var compiler = _this.compilersByMimeType[x];
                  var Klass = Object.getPrototypeOf(compiler).constructor;

                  var val = {
                    name: Klass.name,
                    inputMimeTypes: Klass.getInputMimeTypes(),
                    compilerOptions: compiler.compilerOptions,
                    compilerVersion: compiler.getCompilerVersion()
                  };

                  acc[x] = val;
                  return acc;
                }, {});
                info = {
                  fileChangeCache: this.fileChangeCache.getSavedData(),
                  compilers: serializedCompilerOpts
                };
                target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
                _context.next = 5;
                return _promise.pzlib.gzip(new Buffer(JSON.stringify(info)));

              case 5:
                buf = _context.sent;
                _context.next = 8;
                return _promise.pfs.writeFile(target, buf);

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function saveConfiguration() {
        return ref.apply(this, arguments);
      };
    }()

    /**  
     * Compiles a file and returns the compiled result.
     *    
     * @param  {string} filePath  The path to the file to compile
     *
     * @return {Promise<object>}  An Object with the compiled result
     *
     * @property {Object} hashInfo  The hash information returned from getHashForPath
     * @property {string} code  The source code if the file was a text file
     * @property {Buffer} binaryData  The file if it was a binary file
     * @property {string} mimeType  The MIME type saved in the cache.
     * @property {string[]} dependentFiles  The dependent files returned from 
     *                                      compiling the file, if any.
     */

  }, {
    key: 'compile',
    value: function compile(filePath) {
      return this.readOnlyMode ? this.compileReadOnly(filePath) : this.fullCompile(filePath);
    }

    /**  
     * Handles compilation in read-only mode
     *
     * @private
     */

  }, {
    key: 'compileReadOnly',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(filePath) {
        var type, hashInfo, compiler, _ref, _code, _binaryData, _mimeType, cache, _ref2, code, binaryData, mimeType;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // We guarantee that node_modules are always shipped directly
                type = _mimeTypes2.default.lookup(filePath);

                if (!_fileChangeCache2.default.isInNodeModules(filePath)) {
                  _context2.next = 7;
                  break;
                }

                _context2.t0 = type || 'application/javascript';
                _context2.next = 5;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 5:
                _context2.t1 = _context2.sent;
                return _context2.abrupt('return', {
                  mimeType: _context2.t0,
                  code: _context2.t1
                });

              case 7:
                _context2.next = 9;
                return this.fileChangeCache.getHashForPath(filePath);

              case 9:
                hashInfo = _context2.sent;

                // NB: Here, we're basically only using the compiler here to find
                // the appropriate CompileCache
                compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

                if (compiler) {
                  _context2.next = 20;
                  break;
                }

                compiler = this.fallbackCompiler;

                _context2.next = 15;
                return compiler.get(filePath);

              case 15:
                _ref = _context2.sent;
                _code = _ref.code;
                _binaryData = _ref.binaryData;
                _mimeType = _ref.mimeType;
                return _context2.abrupt('return', { code: _code || _binaryData, mimeType: _mimeType });

              case 20:
                cache = this.cachesForCompilers.get(compiler);
                _context2.next = 23;
                return cache.get(filePath);

              case 23:
                _ref2 = _context2.sent;
                code = _ref2.code;
                binaryData = _ref2.binaryData;
                mimeType = _ref2.mimeType;

                code = code || binaryData;

                if (!(!code || !mimeType)) {
                  _context2.next = 30;
                  break;
                }

                throw new Error('Asked to compile ' + filePath + ' in production, is this file not precompiled?');

              case 30:
                return _context2.abrupt('return', { code: code, mimeType: mimeType });

              case 31:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function compileReadOnly(_x2) {
        return ref.apply(this, arguments);
      };
    }()

    /**  
     * Handles compilation in read-write mode
     *
     * @private
     */

  }, {
    key: 'fullCompile',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(filePath) {
        var _this2 = this;

        var hashInfo, type, code, compiler, cache;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                d('Compiling ' + filePath);

                _context3.next = 3;
                return this.fileChangeCache.getHashForPath(filePath);

              case 3:
                hashInfo = _context3.sent;
                type = _mimeTypes2.default.lookup(filePath);

                if (!hashInfo.isInNodeModules) {
                  _context3.next = 13;
                  break;
                }

                _context3.t0 = hashInfo.sourceCode;

                if (_context3.t0) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 10;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 10:
                _context3.t0 = _context3.sent;

              case 11:
                code = _context3.t0;
                return _context3.abrupt('return', { code: code, mimeType: type });

              case 13:
                compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

                if (!compiler) {
                  d('Falling back to passthrough compiler for ' + filePath);
                  compiler = this.fallbackCompiler;
                }

                if (compiler) {
                  _context3.next = 17;
                  break;
                }

                throw new Error('Couldn\'t find a compiler for ' + filePath);

              case 17:
                cache = this.cachesForCompilers.get(compiler);
                _context3.next = 20;
                return cache.getOrFetch(filePath, function (filePath, hashInfo) {
                  return _this2.compileUncached(filePath, hashInfo, compiler);
                });

              case 20:
                return _context3.abrupt('return', _context3.sent);

              case 21:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function fullCompile(_x3) {
        return ref.apply(this, arguments);
      };
    }()

    /**  
     * Handles invoking compilers independent of caching
     *
     * @private
     */

  }, {
    key: 'compileUncached',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(filePath, hashInfo, compiler) {
        var inputMimeType, ctx, code, dependentFiles, result, shouldInlineHtmlify, isPassthrough;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                inputMimeType = _mimeTypes2.default.lookup(filePath);

                if (!hashInfo.isFileBinary) {
                  _context4.next = 11;
                  break;
                }

                _context4.t0 = hashInfo.binaryData;

                if (_context4.t0) {
                  _context4.next = 7;
                  break;
                }

                _context4.next = 6;
                return _promise.pfs.readFile(filePath);

              case 6:
                _context4.t0 = _context4.sent;

              case 7:
                _context4.t1 = _context4.t0;
                _context4.t2 = inputMimeType;
                _context4.t3 = [];
                return _context4.abrupt('return', {
                  binaryData: _context4.t1,
                  mimeType: _context4.t2,
                  dependentFiles: _context4.t3
                });

              case 11:
                ctx = {};
                _context4.t4 = hashInfo.sourceCode;

                if (_context4.t4) {
                  _context4.next = 17;
                  break;
                }

                _context4.next = 16;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 16:
                _context4.t4 = _context4.sent;

              case 17:
                code = _context4.t4;
                _context4.next = 20;
                return compiler.shouldCompileFile(code, ctx);

              case 20:
                if (_context4.sent) {
                  _context4.next = 23;
                  break;
                }

                d('Compiler returned false for shouldCompileFile: ' + filePath);
                return _context4.abrupt('return', { code: code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] });

              case 23:
                _context4.next = 25;
                return compiler.determineDependentFiles(code, filePath, ctx);

              case 25:
                dependentFiles = _context4.sent;

                d('Using compiler options: ' + JSON.stringify(compiler.compilerOptions));
                _context4.next = 29;
                return compiler.compile(code, filePath, ctx);

              case 29:
                result = _context4.sent;
                shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';
                isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

                if (!(finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough)) {
                  _context4.next = 36;
                  break;
                }

                return _context4.abrupt('return', _lodash2.default.assign(result, { dependentFiles: dependentFiles }));

              case 36:
                d('Recursively compiling result of ' + filePath + ' with non-final MIME type ' + result.mimeType + ', input was ' + inputMimeType);

                hashInfo = _lodash2.default.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
                compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

                if (compiler) {
                  _context4.next = 42;
                  break;
                }

                d('Recursive compile failed - intermediate result: ' + JSON.stringify(result));

                throw new Error('Compiling ' + filePath + ' resulted in a MIME type of ' + result.mimeType + ', which we don\'t know how to handle');

              case 42:
                _context4.next = 44;
                return this.compileUncached(filePath + '.' + _mimeTypes2.default.extension(result.mimeType || 'txt'), hashInfo, compiler);

              case 44:
                return _context4.abrupt('return', _context4.sent);

              case 45:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function compileUncached(_x4, _x5, _x6) {
        return ref.apply(this, arguments);
      };
    }()

    /**  
     * Pre-caches an entire directory of files recursively. Usually used for 
     * building custom compiler tooling.
     *    
     * @param  {string} rootDirectory  The top-level directory to compile
     *
     * @param  {Function} shouldCompile (optional)  A Function which allows the 
     *                                  caller to disable compiling certain files.
     *                                  It takes a fully-qualified path to a file,
     *                                  and should return a Boolean.
     *
     * @return {Promise}  Completion.
     */

  }, {
    key: 'compileAll',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(rootDirectory) {
        var _this3 = this;

        var shouldCompile = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
        var should;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                should = shouldCompile || function () {
                  return true;
                };

                _context5.next = 3;
                return (0, _forAllFiles.forAllFiles)(rootDirectory, function (f) {
                  if (!should(f)) return;

                  d('Compiling ' + f);
                  return _this3.compile(f, _this3.compilersByMimeType);
                });

              case 3:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function compileAll(_x8) {
        return ref.apply(this, arguments);
      };
    }()

    /*
     * Sync Methods
     */

  }, {
    key: 'compileSync',
    value: function compileSync(filePath) {
      return this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath);
    }
  }, {
    key: 'saveConfigurationSync',
    value: function saveConfigurationSync() {
      var _this4 = this;

      var serializedCompilerOpts = _lodash2.default.reduce(Object.keys(this.compilersByMimeType), function (acc, x) {
        var compiler = _this4.compilersByMimeType[x];
        var Klass = Object.getPrototypeOf(compiler).constructor;

        var val = {
          name: Klass.name,
          inputMimeTypes: Klass.getInputMimeTypes(),
          compilerOptions: compiler.compilerOptions,
          compilerVersion: compiler.getCompilerVersion()
        };

        acc[x] = val;
        return acc;
      }, {});

      var info = {
        fileChangeCache: this.fileChangeCache.getSavedData(),
        compilers: serializedCompilerOpts
      };

      var target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
      var buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(info)));
      _fs2.default.writeFileSync(target, buf);
    }
  }, {
    key: 'compileReadOnlySync',
    value: function compileReadOnlySync(filePath) {
      // We guarantee that node_modules are always shipped directly
      var type = _mimeTypes2.default.lookup(filePath);
      if (_fileChangeCache2.default.isInNodeModules(filePath)) {
        return {
          mimeType: type || 'application/javascript',
          code: _fs2.default.readFileSync(filePath, 'utf8')
        };
      }

      var hashInfo = this.fileChangeCache.getHashForPathSync(filePath);

      // We guarantee that node_modules are always shipped directly
      if (hashInfo.isInNodeModules) {
        return {
          mimeType: type,
          code: hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8')
        };
      }

      // NB: Here, we're basically only using the compiler here to find
      // the appropriate CompileCache
      var compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        compiler = this.fallbackCompiler;

        var _compiler$getSync = compiler.getSync(filePath);

        var _code2 = _compiler$getSync.code;
        var _binaryData2 = _compiler$getSync.binaryData;
        var _mimeType2 = _compiler$getSync.mimeType;

        return { code: _code2 || _binaryData2, mimeType: _mimeType2 };
      }

      var cache = this.cachesForCompilers.get(compiler);

      var _cache$getSync = cache.getSync(filePath);

      var code = _cache$getSync.code;
      var binaryData = _cache$getSync.binaryData;
      var mimeType = _cache$getSync.mimeType;

      code = code || binaryData;
      if (!code || !mimeType) {
        throw new Error('Asked to compile ' + filePath + ' in production, is this file not precompiled?');
      }

      return { code: code, mimeType: mimeType };
    }
  }, {
    key: 'fullCompileSync',
    value: function fullCompileSync(filePath) {
      var _this5 = this;

      d('Compiling ' + filePath);

      var hashInfo = this.fileChangeCache.getHashForPathSync(filePath);
      var type = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isInNodeModules) {
        var _code3 = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');
        return { code: _code3, mimeType: type };
      }

      var compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        d('Falling back to passthrough compiler for ' + filePath);
        compiler = this.fallbackCompiler;
      }

      if (!compiler) {
        throw new Error('Couldn\'t find a compiler for ' + filePath);
      }

      var cache = this.cachesForCompilers.get(compiler);
      return cache.getOrFetchSync(filePath, function (filePath, hashInfo) {
        return _this5.compileUncachedSync(filePath, hashInfo, compiler);
      });
    }
  }, {
    key: 'compileUncachedSync',
    value: function compileUncachedSync(filePath, hashInfo, compiler) {
      var inputMimeType = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isFileBinary) {
        return {
          binaryData: hashInfo.binaryData || _fs2.default.readFileSync(filePath),
          mimeType: inputMimeType,
          dependentFiles: []
        };
      }

      var ctx = {};
      var code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');

      if (!compiler.shouldCompileFileSync(code, ctx)) {
        d('Compiler returned false for shouldCompileFile: ' + filePath);
        return { code: code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };
      }

      var dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);

      var result = compiler.compileSync(code, filePath, ctx);

      var shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';

      var isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

      if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {
        // Got something we can use in-browser, let's return it
        return _lodash2.default.assign(result, { dependentFiles: dependentFiles });
      } else {
        d('Recursively compiling result of ' + filePath + ' with non-final MIME type ' + result.mimeType + ', input was ' + inputMimeType);

        hashInfo = _lodash2.default.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
        compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

        if (!compiler) {
          d('Recursive compile failed - intermediate result: ' + JSON.stringify(result));

          throw new Error('Compiling ' + filePath + ' resulted in a MIME type of ' + result.mimeType + ', which we don\'t know how to handle');
        }

        return this.compileUncachedSync(filePath + '.' + _mimeTypes2.default.extension(result.mimeType || 'txt'), hashInfo, compiler);
      }
    }
  }, {
    key: 'compileAllSync',
    value: function compileAllSync(rootDirectory) {
      var _this6 = this;

      var shouldCompile = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      var should = shouldCompile || function () {
        return true;
      };

      (0, _forAllFiles.forAllFilesSync)(rootDirectory, function (f) {
        if (!should(f)) return;
        return _this6.compileSync(f, _this6.compilersByMimeType);
      });
    }

    /*
     * Other stuff
     */

    /**
     * Returns the passthrough compiler 
     *
     * @private
     */

  }, {
    key: 'getPassthroughCompiler',
    value: function getPassthroughCompiler() {
      return this.compilersByMimeType['text/plain'];
    }

    /**
     * Determines whether we should even try to compile the content. Note that in
     * some cases, content will still be in cache even if this returns true, and
     * in other cases (isInNodeModules), we'll know explicitly to not even bother
     * looking in the cache.
     *    
     * @private
     */

  }], [{
    key: 'createReadonlyFromConfiguration',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(rootCacheDir, appRoot) {
        var fallbackCompiler = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
        var target, buf, info, fileChangeCache, compilers;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
                _context6.next = 3;
                return _promise.pfs.readFile(target);

              case 3:
                buf = _context6.sent;
                _context6.t0 = JSON;
                _context6.next = 7;
                return _promise.pzlib.gunzip(buf);

              case 7:
                _context6.t1 = _context6.sent;
                info = _context6.t0.parse.call(_context6.t0, _context6.t1);
                fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);
                compilers = _lodash2.default.reduce(Object.keys(info.compilers), function (acc, x) {
                  var cur = info.compilers[x];
                  acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

                  return acc;
                }, {});
                return _context6.abrupt('return', new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler));

              case 12:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function createReadonlyFromConfiguration(_x11, _x12) {
        return ref.apply(this, arguments);
      };
    }()

    /**    
     * Creates a development-mode CompilerHost from the previously saved 
     * configuration.
     *    
     * @param  {string} rootCacheDir  The root directory to use for the cache. This
     *                                cache must have cache information saved via
     *                                {@link saveConfiguration}
     *
     * @param  {string} appRoot  The top-level directory for your application (i.e.
     *                           the one which has your package.json).
     *
     * @param  {Object} compilersByMimeType  an Object whose keys are input MIME 
     *                                       types and whose values are instances 
     *                                       of CompilerBase. Create this via the 
     *                                       {@link createCompilers} method in 
     *                                       config-parser.
     * 
     * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
     *                                         which doesn't have a matching compiler,
     *                                         this compiler will be used instead. If
     *                                         null, will fail compilation. A good
     *                                         alternate fallback is the compiler for
     *                                         'text/plain', which is guaranteed to be
     *                                         present. 
     *
     * @return {Promise<CompilerHost>}  A read-only CompilerHost
     */

  }, {
    key: 'createFromConfiguration',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(rootCacheDir, appRoot, compilersByMimeType) {
        var fallbackCompiler = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
        var target, buf, info, fileChangeCache;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
                _context7.next = 3;
                return _promise.pfs.readFile(target);

              case 3:
                buf = _context7.sent;
                _context7.t0 = JSON;
                _context7.next = 7;
                return _promise.pzlib.gunzip(buf);

              case 7:
                _context7.t1 = _context7.sent;
                info = _context7.t0.parse.call(_context7.t0, _context7.t1);
                fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

                _lodash2.default.each(Object.keys(info.compilers), function (x) {
                  var cur = info.compilers[x];
                  compilersByMimeType[x].compilerOptions = cur.compilerOptions;
                });

                return _context7.abrupt('return', new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler));

              case 12:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function createFromConfiguration(_x14, _x15, _x16) {
        return ref.apply(this, arguments);
      };
    }()
  }, {
    key: 'createReadonlyFromConfigurationSync',
    value: function createReadonlyFromConfigurationSync(rootCacheDir, appRoot) {
      var fallbackCompiler = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

      var target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      var buf = _fs2.default.readFileSync(target);
      var info = JSON.parse(_zlib2.default.gunzipSync(buf));

      var fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);

      var compilers = _lodash2.default.reduce(Object.keys(info.compilers), function (acc, x) {
        var cur = info.compilers[x];
        acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

        return acc;
      }, {});

      return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);
    }
  }, {
    key: 'createFromConfigurationSync',
    value: function createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType) {
      var fallbackCompiler = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

      var target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      var buf = _fs2.default.readFileSync(target);
      var info = JSON.parse(_zlib2.default.gunzipSync(buf));

      var fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

      _lodash2.default.each(Object.keys(info.compilers), function (x) {
        var cur = info.compilers[x];
        compilersByMimeType[x].compilerOptions = cur.compilerOptions;
      });

      return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);
    }
  }, {
    key: 'shouldPassthrough',
    value: function shouldPassthrough(hashInfo) {
      return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;
    }
  }]);

  return CompilerHost;
}();

exports.default = CompilerHost;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlci1ob3N0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWUEsSUFBTSxJQUFJLFFBQVEsT0FBUixFQUFpQixnQ0FBakIsQ0FBSjs7O0FBR04sSUFBTSxhQUFhO0FBQ2pCLHFCQUFtQixJQUFuQjtBQUNBLDRCQUEwQixJQUExQjtBQUNBLGVBQWEsSUFBYjtBQUNBLGNBQVksSUFBWjtBQUNBLG1CQUFpQixJQUFqQjtBQUNBLHNCQUFvQixJQUFwQjtDQU5JOzs7Ozs7Ozs7Ozs7Ozs7OztJQXVCZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCbkIsV0EzQm1CLFlBMkJuQixDQUFZLFlBQVosRUFBMEIsU0FBMUIsRUFBcUMsZUFBckMsRUFBc0QsWUFBdEQsRUFBNkY7UUFBekIseUVBQW1CLG9CQUFNOzswQkEzQjFFLGNBMkIwRTs7QUFDM0YsUUFBSSxzQkFBc0IsaUJBQUUsTUFBRixDQUFTLEVBQVQsRUFBYSxTQUFiLENBQXRCLENBRHVGO0FBRTNGLHFCQUFFLE1BQUYsQ0FBUyxJQUFULEVBQWUsRUFBQywwQkFBRCxFQUFlLHdDQUFmLEVBQW9DLGdDQUFwQyxFQUFxRCwwQkFBckQsRUFBbUUsa0NBQW5FLEVBQWYsRUFGMkY7QUFHM0YsU0FBSyxPQUFMLEdBQWUsS0FBSyxlQUFMLENBQXFCLE9BQXJCLENBSDRFOztBQUszRixTQUFLLGtCQUFMLEdBQTBCLGlCQUFFLE1BQUYsQ0FBUyxPQUFPLElBQVAsQ0FBWSxtQkFBWixDQUFULEVBQTJDLFVBQUMsR0FBRCxFQUFNLENBQU4sRUFBWTtBQUMvRSxVQUFJLFdBQVcsb0JBQW9CLENBQXBCLENBQVgsQ0FEMkU7QUFFL0UsVUFBSSxJQUFJLEdBQUosQ0FBUSxRQUFSLENBQUosRUFBdUIsT0FBTyxHQUFQLENBQXZCOztBQUVBLFVBQUksR0FBSixDQUNFLFFBREYsRUFFRSx1QkFBYSxrQkFB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QVQsSUFBeUIsU0FBUyxZQUFULENBRGxEOzs7O1NBaGpCaEIiLCJmaWxlIjoiY29tcGlsZXItaG9zdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbWltZVR5cGVzIGZyb20gJ21pbWUtdHlwZXMnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge3BmcywgcHpsaWJ9IGZyb20gJy4vcHJvbWlzZSc7XG5cbmltcG9ydCB7Zm9yQWxsRmlsZXMsIGZvckFsbEZpbGVzU3luY30gZnJvbSAnLi9mb3ItYWxsLWZpbGVzJztcbmltcG9ydCBDb21waWxlQ2FjaGUgZnJvbSAnLi9jb21waWxlLWNhY2hlJztcbmltcG9ydCBGaWxlQ2hhbmdlZENhY2hlIGZyb20gJy4vZmlsZS1jaGFuZ2UtY2FjaGUnO1xuaW1wb3J0IFJlYWRPbmx5Q29tcGlsZXIgZnJvbSAnLi9yZWFkLW9ubHktY29tcGlsZXInO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpjb21waWxlci1ob3N0Jyk7XG5cbi8vIFRoaXMgaXNuJ3QgZXZlbiBteVxuY29uc3QgZmluYWxGb3JtcyA9IHtcbiAgJ3RleHQvamF2YXNjcmlwdCc6IHRydWUsXG4gICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzogdHJ1ZSxcbiAgJ3RleHQvaHRtbCc6IHRydWUsXG4gICd0ZXh0L2Nzcyc6IHRydWUsXG4gICdpbWFnZS9zdmcreG1sJzogdHJ1ZSxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiB0cnVlXG59O1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgdGhlIHRvcC1sZXZlbCBjbGFzcyB0aGF0IGVuY2Fwc3VsYXRlcyBhbGwgb2YgdGhlIGxvZ2ljIG9mIFxuICogY29tcGlsaW5nIGFuZCBjYWNoaW5nIGFwcGxpY2F0aW9uIGNvZGUuIElmIHlvdSdyZSBsb29raW5nIGZvciBhIFwiTWFpbiBjbGFzc1wiLFxuICogdGhpcyBpcyBpdC5cbiAqIFxuICogVGhpcyBjbGFzcyBjYW4gYmUgY3JlYXRlZCBkaXJlY3RseSBidXQgaXQgaXMgdXN1YWxseSBjcmVhdGVkIHZpYSB0aGUgbWV0aG9kc1xuICogaW4gY29uZmlnLXBhcnNlciwgd2hpY2ggd2lsbCBhbW9uZyBvdGhlciB0aGluZ3MsIHNldCB1cCB0aGUgY29tcGlsZXIgb3B0aW9uc1xuICogZ2l2ZW4gYSBwcm9qZWN0IHJvb3QuXG4gKiBcbiAqIENvbXBpbGVySG9zdCBpcyBhbHNvIHRoZSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gc2VyaWFsaXplIGFsbCBvZiB0aGVcbiAqIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byByZWNyZWF0ZSBpdHNlbGYsIGVpdGhlciBhcyBhIGRldmVsb3BtZW50IGhvc3QgKGkuZS5cbiAqIHdpbGwgYWxsb3cgY2FjaGUgbWlzc2VzIGFuZCBhY3R1YWwgY29tcGlsYXRpb24pLCBvciBhcyBhIHJlYWQtb25seSB2ZXJzaW9uIG9mXG4gKiBpdHNlbGYgZm9yIHByb2R1Y3Rpb24uXG4gKi8gXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlckhvc3Qge1xuICAvKiogIFxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENvbXBpbGVySG9zdC4gWW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIHRoZSBtZXRob2RzXG4gICAqIGluIGNvbmZpZy1wYXJzZXIgZm9yIGRldmVsb3BtZW50LCBvciB7QGxpbmsgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbn1cbiAgICogZm9yIHByb2R1Y3Rpb24gaW5zdGVhZC5cbiAgICogICAgXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcm9vdENhY2hlRGlyICBUaGUgcm9vdCBkaXJlY3RvcnkgdG8gdXNlIGZvciB0aGUgY2FjaGVcbiAgICogXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29tcGlsZXJzICBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgaW5wdXQgTUlNRSB0eXBlcyBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdob3NlIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIENvbXBpbGVyQmFzZS4gQ3JlYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHZpYSB0aGUge0BsaW5rIGNyZWF0ZUNvbXBpbGVyc30gbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWctcGFyc2VyLlxuICAgKiBcbiAgICogQHBhcmFtICB7RmlsZUNoYW5nZWRDYWNoZX0gZmlsZUNoYW5nZUNhY2hlICBBIGZpbGUtY2hhbmdlIGNhY2hlIHRoYXQgaXMgXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxseSBwcmUtbG9hZGVkLlxuICAgKiBcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmVhZE9ubHlNb2RlICBJZiBUcnVlLCBjYWNoZSBtaXNzZXMgd2lsbCBmYWlsIGFuZCBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21waWxhdGlvbiB3aWxsIG5vdCBiZSBhdHRlbXB0ZWQuXG4gICAqIFxuICAgKiBAcGFyYW0gIHtDb21waWxlckJhc2V9IGZhbGxiYWNrQ29tcGlsZXIgKG9wdGlvbmFsKSAgV2hlbiBhIGZpbGUgaXMgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHdpbGwgZmFpbCBjb21waWxhdGlvbi4gQSBnb29kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50LlxuICAgKi8gICBcbiAgY29uc3RydWN0b3Iocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgcmVhZE9ubHlNb2RlLCBmYWxsYmFja0NvbXBpbGVyID0gbnVsbCkge1xuICAgIGxldCBjb21waWxlcnNCeU1pbWVUeXBlID0gXy5hc3NpZ24oe30sIGNvbXBpbGVycyk7XG4gICAgXy5hc3NpZ24odGhpcywge3Jvb3RDYWNoZURpciwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmlsZUNoYW5nZUNhY2hlLCByZWFkT25seU1vZGUsIGZhbGxiYWNrQ29tcGlsZXJ9KTtcbiAgICB0aGlzLmFwcFJvb3QgPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5hcHBSb290O1xuICAgIFxuICAgIHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzID0gXy5yZWR1Y2UoT2JqZWN0LmtleXMoY29tcGlsZXJzQnlNaW1lVHlwZSksIChhY2MsIHgpID0+IHtcbiAgICAgIGxldCBjb21waWxlciA9IGNvbXBpbGVyc0J5TWltZVR5cGVbeF07XG4gICAgICBpZiAoYWNjLmhhcyhjb21waWxlcikpIHJldHVybiBhY2M7XG5cbiAgICAgIGFjYy5zZXQoXG4gICAgICAgIGNvbXBpbGVyLCBcbiAgICAgICAgQ29tcGlsZUNhY2hlLmNyZWF0ZUZyb21Db21waWxlcihyb290Q2FjaGVEaXIsIGNvbXBpbGVyLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSkpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBuZXcgTWFwKCkpO1xuICB9XG4gICAgXG4gIC8qKiAgICBcbiAgICogQ3JlYXRlcyBhIHByb2R1Y3Rpb24tbW9kZSBDb21waWxlckhvc3QgZnJvbSB0aGUgcHJldmlvdXNseSBzYXZlZCBcbiAgICogY29uZmlndXJhdGlvblxuICAgKiAgICBcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZS4gVGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgbXVzdCBoYXZlIGNhY2hlIGluZm9ybWF0aW9uIHNhdmVkIHZpYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21waWxlckJhc2V9IGZhbGxiYWNrQ29tcGlsZXIgKG9wdGlvbmFsKSAgV2hlbiBhIGZpbGUgaXMgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHdpbGwgZmFpbCBjb21waWxhdGlvbi4gQSBnb29kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50LiBcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSByZWFkLW9ubHkgQ29tcGlsZXJIb3N0XG4gICAqLyAgIFxuICBzdGF0aWMgYXN5bmMgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbihyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGZhbGxiYWNrQ29tcGlsZXI9bnVsbCkge1xuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZSh0YXJnZXQpO1xuICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwemxpYi5ndW56aXAoYnVmKSk7XG4gICAgXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCB0cnVlKTtcblxuICAgIGxldCBjb21waWxlcnMgPSBfLnJlZHVjZShPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycyksIChhY2MsIHgpID0+IHtcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcbiAgICAgIGFjY1t4XSA9IG5ldyBSZWFkT25seUNvbXBpbGVyKGN1ci5uYW1lLCBjdXIuY29tcGlsZXJWZXJzaW9uLCBjdXIuY29tcGlsZXJPcHRpb25zLCBjdXIuaW5wdXRNaW1lVHlwZXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBcbiAgICByZXR1cm4gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCB0cnVlLCBmYWxsYmFja0NvbXBpbGVyKTtcbiAgfVxuXG4gIC8qKiAgICBcbiAgICogQ3JlYXRlcyBhIGRldmVsb3BtZW50LW1vZGUgQ29tcGlsZXJIb3N0IGZyb20gdGhlIHByZXZpb3VzbHkgc2F2ZWQgXG4gICAqIGNvbmZpZ3VyYXRpb24uXG4gICAqICAgIFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSBtdXN0IGhhdmUgY2FjaGUgaW5mb3JtYXRpb24gc2F2ZWQgdmlhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgc2F2ZUNvbmZpZ3VyYXRpb259XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29tcGlsZXJzQnlNaW1lVHlwZSAgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIGlucHV0IE1JTUUgXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgYW5kIHdob3NlIHZhbHVlcyBhcmUgaW5zdGFuY2VzIFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIENvbXBpbGVyQmFzZS4gQ3JlYXRlIHRoaXMgdmlhIHRoZSBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgY3JlYXRlQ29tcGlsZXJzfSBtZXRob2QgaW4gXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLXBhcnNlci5cbiAgICogXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggZG9lc24ndCBoYXZlIGEgbWF0Y2hpbmcgY29tcGlsZXIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0ZSBmYWxsYmFjayBpcyB0aGUgY29tcGlsZXIgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuIFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHJlYWQtb25seSBDb21waWxlckhvc3RcbiAgICovICAgXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVGcm9tQ29uZmlndXJhdGlvbihyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGNvbXBpbGVyc0J5TWltZVR5cGUsIGZhbGxiYWNrQ29tcGlsZXI9bnVsbCkge1xuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZSh0YXJnZXQpO1xuICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwemxpYi5ndW56aXAoYnVmKSk7XG4gICAgXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCBmYWxzZSk7XG4gICAgXG4gICAgXy5lYWNoKE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKSwgKHgpID0+IHtcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcbiAgICAgIGNvbXBpbGVyc0J5TWltZVR5cGVbeF0uY29tcGlsZXJPcHRpb25zID0gY3VyLmNvbXBpbGVyT3B0aW9ucztcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVyc0J5TWltZVR5cGUsIGZpbGVDaGFuZ2VDYWNoZSwgZmFsc2UsIGZhbGxiYWNrQ29tcGlsZXIpO1xuICB9XG4gIFxuICBcbiAgLyoqICBcbiAgICogU2F2ZXMgdGhlIGN1cnJlbnQgY29tcGlsZXIgY29uZmlndXJhdGlvbiB0byBhIGZpbGUgdGhhdCBcbiAgICoge0BsaW5rIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb259IGNhbiB1c2UgdG8gcmVjcmVhdGUgdGhlIGN1cnJlbnQgXG4gICAqIGNvbXBpbGVyIGVudmlyb25tZW50XG4gICAqICAgIFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgQ29tcGxldGlvblxuICAgKi8gICBcbiAgYXN5bmMgc2F2ZUNvbmZpZ3VyYXRpb24oKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRDb21waWxlck9wdHMgPSBfLnJlZHVjZShPYmplY3Qua2V5cyh0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpLCAoYWNjLCB4KSA9PiB7XG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XG4gICAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yO1xuICAgICAgXG4gICAgICBsZXQgdmFsID0ge1xuICAgICAgICBuYW1lOiBLbGFzcy5uYW1lLFxuICAgICAgICBpbnB1dE1pbWVUeXBlczogS2xhc3MuZ2V0SW5wdXRNaW1lVHlwZXMoKSxcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXG4gICAgICAgIGNvbXBpbGVyVmVyc2lvbjogY29tcGlsZXIuZ2V0Q29tcGlsZXJWZXJzaW9uKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGFjY1t4XSA9IHZhbDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIFxuICAgIGxldCBpbmZvID0ge1xuICAgICAgZmlsZUNoYW5nZUNhY2hlOiB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRTYXZlZERhdGEoKSxcbiAgICAgIGNvbXBpbGVyczogc2VyaWFsaXplZENvbXBpbGVyT3B0c1xuICAgIH07XG4gICAgXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLnJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xuICAgIGxldCBidWYgPSBhd2FpdCBwemxpYi5nemlwKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoaW5mbykpKTtcbiAgICBhd2FpdCBwZnMud3JpdGVGaWxlKHRhcmdldCwgYnVmKTtcbiAgfVxuICBcbiAgLyoqICBcbiAgICogQ29tcGlsZXMgYSBmaWxlIGFuZCByZXR1cm5zIHRoZSBjb21waWxlZCByZXN1bHQuXG4gICAqICAgIFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVQYXRoICBUaGUgcGF0aCB0byB0aGUgZmlsZSB0byBjb21waWxlXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8b2JqZWN0Pn0gIEFuIE9iamVjdCB3aXRoIHRoZSBjb21waWxlZCByZXN1bHRcbiAgICpcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGhhc2hJbmZvICBUaGUgaGFzaCBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGdldEhhc2hGb3JQYXRoXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlICBUaGUgc291cmNlIGNvZGUgaWYgdGhlIGZpbGUgd2FzIGEgdGV4dCBmaWxlXG4gICAqIEBwcm9wZXJ0eSB7QnVmZmVyfSBiaW5hcnlEYXRhICBUaGUgZmlsZSBpZiBpdCB3YXMgYSBiaW5hcnkgZmlsZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWltZVR5cGUgIFRoZSBNSU1FIHR5cGUgc2F2ZWQgaW4gdGhlIGNhY2hlLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBkZXBlbmRlbnRGaWxlcyAgVGhlIGRlcGVuZGVudCBmaWxlcyByZXR1cm5lZCBmcm9tIFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsaW5nIHRoZSBmaWxlLCBpZiBhbnkuXG4gICAqLyAgIFxuICBjb21waWxlKGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlYWRPbmx5TW9kZSA/IHRoaXMuY29tcGlsZVJlYWRPbmx5KGZpbGVQYXRoKSA6IHRoaXMuZnVsbENvbXBpbGUoZmlsZVBhdGgpKTtcbiAgfVxuICBcbiAgXG4gIC8qKiAgXG4gICAqIEhhbmRsZXMgY29tcGlsYXRpb24gaW4gcmVhZC1vbmx5IG1vZGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovICAgXG4gIGFzeW5jIGNvbXBpbGVSZWFkT25seShmaWxlUGF0aCkge1xuICAgIC8vIFdlIGd1YXJhbnRlZSB0aGF0IG5vZGVfbW9kdWxlcyBhcmUgYWx3YXlzIHNoaXBwZWQgZGlyZWN0bHlcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xuICAgIGlmIChGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhmaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBtaW1lVHlwZTogdHlwZSB8fCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgICAgIGNvZGU6IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKSBcbiAgICAgIH07ICAgIFxuICAgIH1cbiAgICBcbiAgICBsZXQgaGFzaEluZm8gPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aChmaWxlUGF0aCk7XG5cbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxuICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBDb21waWxlQ2FjaGVcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgIGlmICghY29tcGlsZXIpIHsgXG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcblxuICAgICAgbGV0IHsgY29kZSwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfSA9IGF3YWl0IGNvbXBpbGVyLmdldChmaWxlUGF0aCk7XG4gICAgICByZXR1cm4geyBjb2RlOiBjb2RlIHx8IGJpbmFyeURhdGEsIG1pbWVUeXBlIH07XG4gICAgfVxuXG4gICAgbGV0IGNhY2hlID0gdGhpcy5jYWNoZXNGb3JDb21waWxlcnMuZ2V0KGNvbXBpbGVyKTtcbiAgICBsZXQge2NvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlfSA9IGF3YWl0IGNhY2hlLmdldChmaWxlUGF0aCk7XG5cbiAgICBjb2RlID0gY29kZSB8fCBiaW5hcnlEYXRhO1xuICAgIGlmICghY29kZSB8fCAhbWltZVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofSBpbiBwcm9kdWN0aW9uLCBpcyB0aGlzIGZpbGUgbm90IHByZWNvbXBpbGVkP2ApO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlIH07XG4gIH1cblxuICAvKiogIFxuICAgKiBIYW5kbGVzIGNvbXBpbGF0aW9uIGluIHJlYWQtd3JpdGUgbW9kZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi8gICAgIFxuICBhc3luYyBmdWxsQ29tcGlsZShmaWxlUGF0aCkge1xuICAgIGQoYENvbXBpbGluZyAke2ZpbGVQYXRofWApO1xuICAgIFxuICAgIGxldCBoYXNoSW5mbyA9IGF3YWl0IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoKGZpbGVQYXRoKTtcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xuICAgIFxuICAgIGlmIChoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcbiAgICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogdHlwZSB9O1xuICAgIH1cblxuICAgIGxldCBjb21waWxlciA9IENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykgP1xuICAgICAgdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkgOlxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xuXG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgZChgRmFsbGluZyBiYWNrIHRvIHBhc3N0aHJvdWdoIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XG4gICAgfVxuXG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIGEgY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XG4gICAgfVxuXG4gICAgbGV0IGNhY2hlID0gdGhpcy5jYWNoZXNGb3JDb21waWxlcnMuZ2V0KGNvbXBpbGVyKTtcbiAgICByZXR1cm4gYXdhaXQgY2FjaGUuZ2V0T3JGZXRjaChcbiAgICAgIGZpbGVQYXRoLFxuICAgICAgKGZpbGVQYXRoLCBoYXNoSW5mbykgPT4gdGhpcy5jb21waWxlVW5jYWNoZWQoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xuICB9XG5cbiAgLyoqICBcbiAgICogSGFuZGxlcyBpbnZva2luZyBjb21waWxlcnMgaW5kZXBlbmRlbnQgb2YgY2FjaGluZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgY29tcGlsZVVuY2FjaGVkKGZpbGVQYXRoLCBoYXNoSW5mbywgY29tcGlsZXIpIHtcbiAgICBsZXQgaW5wdXRNaW1lVHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xuICAgIFxuICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJpbmFyeURhdGE6IGhhc2hJbmZvLmJpbmFyeURhdGEgfHwgYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGVQYXRoKSxcbiAgICAgICAgbWltZVR5cGU6IGlucHV0TWltZVR5cGUsXG4gICAgICAgIGRlcGVuZGVudEZpbGVzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgbGV0IGN0eCA9IHt9O1xuICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XG5cbiAgICBpZiAoIShhd2FpdCBjb21waWxlci5zaG91bGRDb21waWxlRmlsZShjb2RlLCBjdHgpKSkge1xuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpLCBkZXBlbmRlbnRGaWxlczogW10gfTtcbiAgICB9XG5cbiAgICBsZXQgZGVwZW5kZW50RmlsZXMgPSBhd2FpdCBjb21waWxlci5kZXRlcm1pbmVEZXBlbmRlbnRGaWxlcyhjb2RlLCBmaWxlUGF0aCwgY3R4KTtcblxuICAgIGQoYFVzaW5nIGNvbXBpbGVyIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoY29tcGlsZXIuY29tcGlsZXJPcHRpb25zKX1gKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY29tcGlsZXIuY29tcGlsZShjb2RlLCBmaWxlUGF0aCwgY3R4KTtcblxuICAgIGxldCBzaG91bGRJbmxpbmVIdG1saWZ5ID0gXG4gICAgICBpbnB1dE1pbWVUeXBlICE9PSAndGV4dC9odG1sJyAmJlxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9odG1sJztcbiAgICBcbiAgICBsZXQgaXNQYXNzdGhyb3VnaCA9IFxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9wbGFpbicgfHwgXG4gICAgICAhcmVzdWx0Lm1pbWVUeXBlIHx8IFxuICAgICAgQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKTtcbiAgICAgIFxuICAgIGlmICgoZmluYWxGb3Jtc1tyZXN1bHQubWltZVR5cGVdICYmICFzaG91bGRJbmxpbmVIdG1saWZ5KSB8fCBpc1Bhc3N0aHJvdWdoKSB7XG4gICAgICAvLyBHb3Qgc29tZXRoaW5nIHdlIGNhbiB1c2UgaW4tYnJvd3NlciwgbGV0J3MgcmV0dXJuIGl0XG4gICAgICByZXR1cm4gXy5hc3NpZ24ocmVzdWx0LCB7ZGVwZW5kZW50RmlsZXN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZChgUmVjdXJzaXZlbHkgY29tcGlsaW5nIHJlc3VsdCBvZiAke2ZpbGVQYXRofSB3aXRoIG5vbi1maW5hbCBNSU1FIHR5cGUgJHtyZXN1bHQubWltZVR5cGV9LCBpbnB1dCB3YXMgJHtpbnB1dE1pbWVUeXBlfWApO1xuXG4gICAgICBoYXNoSW5mbyA9IF8uYXNzaWduKHsgc291cmNlQ29kZTogcmVzdWx0LmNvZGUsIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSwgaGFzaEluZm8pO1xuICAgICAgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbcmVzdWx0Lm1pbWVUeXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgICAgaWYgKCFjb21waWxlcikge1xuICAgICAgICBkKGBSZWN1cnNpdmUgY29tcGlsZSBmYWlsZWQgLSBpbnRlcm1lZGlhdGUgcmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxpbmcgJHtmaWxlUGF0aH0gcmVzdWx0ZWQgaW4gYSBNSU1FIHR5cGUgb2YgJHtyZXN1bHQubWltZVR5cGV9LCB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29tcGlsZVVuY2FjaGVkKFxuICAgICAgICBgJHtmaWxlUGF0aH0uJHttaW1lVHlwZXMuZXh0ZW5zaW9uKHJlc3VsdC5taW1lVHlwZSB8fCAndHh0Jyl9YCwgXG4gICAgICAgIGhhc2hJbmZvLCBjb21waWxlcik7XG4gICAgfVxuICB9XG4gIFxuICAvKiogIFxuICAgKiBQcmUtY2FjaGVzIGFuIGVudGlyZSBkaXJlY3Rvcnkgb2YgZmlsZXMgcmVjdXJzaXZlbHkuIFVzdWFsbHkgdXNlZCBmb3IgXG4gICAqIGJ1aWxkaW5nIGN1c3RvbSBjb21waWxlciB0b29saW5nLlxuICAgKiAgICBcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290RGlyZWN0b3J5ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSB0byBjb21waWxlXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBzaG91bGRDb21waWxlIChvcHRpb25hbCkgIEEgRnVuY3Rpb24gd2hpY2ggYWxsb3dzIHRoZSBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVyIHRvIGRpc2FibGUgY29tcGlsaW5nIGNlcnRhaW4gZmlsZXMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0IHRha2VzIGEgZnVsbHktcXVhbGlmaWVkIHBhdGggdG8gYSBmaWxlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2hvdWxkIHJldHVybiBhIEJvb2xlYW4uXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBDb21wbGV0aW9uLlxuICAgKi8gICBcbiAgYXN5bmMgY29tcGlsZUFsbChyb290RGlyZWN0b3J5LCBzaG91bGRDb21waWxlPW51bGwpIHtcbiAgICBsZXQgc2hvdWxkID0gc2hvdWxkQ29tcGlsZSB8fCBmdW5jdGlvbigpIHtyZXR1cm4gdHJ1ZTt9O1xuXG4gICAgYXdhaXQgZm9yQWxsRmlsZXMocm9vdERpcmVjdG9yeSwgKGYpID0+IHtcbiAgICAgIGlmICghc2hvdWxkKGYpKSByZXR1cm47XG5cbiAgICAgIGQoYENvbXBpbGluZyAke2Z9YCk7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlKGYsIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSk7XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qXG4gICAqIFN5bmMgTWV0aG9kc1xuICAgKi9cbiAgIFxuICBjb21waWxlU3luYyhmaWxlUGF0aCkge1xuICAgIHJldHVybiAodGhpcy5yZWFkT25seU1vZGUgPyB0aGlzLmNvbXBpbGVSZWFkT25seVN5bmMoZmlsZVBhdGgpIDogdGhpcy5mdWxsQ29tcGlsZVN5bmMoZmlsZVBhdGgpKTtcbiAgfVxuICBcbiAgc3RhdGljIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbihyb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKHRhcmdldCk7XG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcbiAgICBcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIHRydWUpO1xuICAgIFxuICAgIGxldCBjb21waWxlcnMgPSBfLnJlZHVjZShPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycyksIChhY2MsIHgpID0+IHtcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcbiAgICAgIGFjY1t4XSA9IG5ldyBSZWFkT25seUNvbXBpbGVyKGN1ci5uYW1lLCBjdXIuY29tcGlsZXJWZXJzaW9uLCBjdXIuY29tcGlsZXJPcHRpb25zLCBjdXIuaW5wdXRNaW1lVHlwZXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBcbiAgICByZXR1cm4gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCB0cnVlLCBmYWxsYmFja0NvbXBpbGVyKTtcbiAgfVxuICBcbiAgc3RhdGljIGNyZWF0ZUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGNvbXBpbGVyc0J5TWltZVR5cGUsIGZhbGxiYWNrQ29tcGlsZXI9bnVsbCkge1xuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpO1xuICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZSh6bGliLmd1bnppcFN5bmMoYnVmKSk7XG4gICAgXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCBmYWxzZSk7XG4gICAgXG4gICAgXy5lYWNoKE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKSwgKHgpID0+IHtcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcbiAgICAgIGNvbXBpbGVyc0J5TWltZVR5cGVbeF0uY29tcGlsZXJPcHRpb25zID0gY3VyLmNvbXBpbGVyT3B0aW9ucztcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVyc0J5TWltZVR5cGUsIGZpbGVDaGFuZ2VDYWNoZSwgZmFsc2UsIGZhbGxiYWNrQ29tcGlsZXIpO1xuICB9XG4gICBcbiAgc2F2ZUNvbmZpZ3VyYXRpb25TeW5jKCkge1xuICAgIGxldCBzZXJpYWxpemVkQ29tcGlsZXJPcHRzID0gXy5yZWR1Y2UoT2JqZWN0LmtleXModGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKSwgKGFjYywgeCkgPT4ge1xuICAgICAgbGV0IGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3hdO1xuICAgICAgbGV0IEtsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbXBpbGVyKS5jb25zdHJ1Y3RvcjtcbiAgICAgIFxuICAgICAgbGV0IHZhbCA9IHtcbiAgICAgICAgbmFtZTogS2xhc3MubmFtZSxcbiAgICAgICAgaW5wdXRNaW1lVHlwZXM6IEtsYXNzLmdldElucHV0TWltZVR5cGVzKCksXG4gICAgICAgIGNvbXBpbGVyT3B0aW9uczogY29tcGlsZXIuY29tcGlsZXJPcHRpb25zLFxuICAgICAgICBjb21waWxlclZlcnNpb246IGNvbXBpbGVyLmdldENvbXBpbGVyVmVyc2lvbigpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBhY2NbeF0gPSB2YWw7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBcbiAgICBsZXQgaW5mbyA9IHtcbiAgICAgIGZpbGVDaGFuZ2VDYWNoZTogdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0U2F2ZWREYXRhKCksXG4gICAgICBjb21waWxlcnM6IHNlcmlhbGl6ZWRDb21waWxlck9wdHNcbiAgICB9O1xuICAgIFxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5yb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcbiAgICBsZXQgYnVmID0gemxpYi5nemlwU3luYyhuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KGluZm8pKSk7XG4gICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQsIGJ1Zik7XG4gIH1cbiAgXG4gIGNvbXBpbGVSZWFkT25seVN5bmMoZmlsZVBhdGgpIHtcbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XG4gICAgICByZXR1cm4geyBcbiAgICAgICAgbWltZVR5cGU6IHR5cGUgfHwgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICAgICAgICBjb2RlOiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4JykgXG4gICAgICB9OyAgICBcbiAgICB9ICBcblxuICAgIGxldCBoYXNoSW5mbyA9IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoU3luYyhmaWxlUGF0aCk7XG4gICAgXG4gICAgLy8gV2UgZ3VhcmFudGVlIHRoYXQgbm9kZV9tb2R1bGVzIGFyZSBhbHdheXMgc2hpcHBlZCBkaXJlY3RseVxuICAgIGlmIChoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBtaW1lVHlwZTogdHlwZSwgXG4gICAgICAgIGNvZGU6IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpIFxuICAgICAgfTsgICAgXG4gICAgfVxuXG4gICAgLy8gTkI6IEhlcmUsIHdlJ3JlIGJhc2ljYWxseSBvbmx5IHVzaW5nIHRoZSBjb21waWxlciBoZXJlIHRvIGZpbmRcbiAgICAvLyB0aGUgYXBwcm9wcmlhdGUgQ29tcGlsZUNhY2hlXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XG4gICAgICB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSA6XG4gICAgICB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbdHlwZSB8fCAnX19sb2xub3RoZXJlJ107XG5cbiAgICBpZiAoIWNvbXBpbGVyKSB7IFxuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XG5cbiAgICAgIGxldCB7IGNvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlIH0gPSBjb21waWxlci5nZXRTeW5jKGZpbGVQYXRoKTtcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcbiAgICB9XG5cbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xuICAgIGxldCB7Y29kZSwgYmluYXJ5RGF0YSwgbWltZVR5cGV9ID0gY2FjaGUuZ2V0U3luYyhmaWxlUGF0aCk7XG5cbiAgICBjb2RlID0gY29kZSB8fCBiaW5hcnlEYXRhO1xuICAgIGlmICghY29kZSB8fCAhbWltZVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofSBpbiBwcm9kdWN0aW9uLCBpcyB0aGlzIGZpbGUgbm90IHByZWNvbXBpbGVkP2ApO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlIH07XG4gIH1cblxuICBmdWxsQ29tcGlsZVN5bmMoZmlsZVBhdGgpIHtcbiAgICBkKGBDb21waWxpbmcgJHtmaWxlUGF0aH1gKTtcblxuICAgIGxldCBoYXNoSW5mbyA9IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoU3luYyhmaWxlUGF0aCk7XG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcbiAgICBcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XG4gICAgICBsZXQgY29kZSA9IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IHR5cGUgfTtcbiAgICB9XG5cbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgIGQoYEZhbGxpbmcgYmFjayB0byBwYXNzdGhyb3VnaCBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xuICAgIH1cblxuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBhIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xuICAgIH1cblxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XG4gICAgcmV0dXJuIGNhY2hlLmdldE9yRmV0Y2hTeW5jKFxuICAgICAgZmlsZVBhdGgsXG4gICAgICAoZmlsZVBhdGgsIGhhc2hJbmZvKSA9PiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xuICB9XG5cbiAgY29tcGlsZVVuY2FjaGVkU3luYyhmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSB7XG4gICAgbGV0IGlucHV0TWltZVR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcbiAgICBcbiAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiaW5hcnlEYXRhOiBoYXNoSW5mby5iaW5hcnlEYXRhIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCksXG4gICAgICAgIG1pbWVUeXBlOiBpbnB1dE1pbWVUeXBlLFxuICAgICAgICBkZXBlbmRlbnRGaWxlczogW11cbiAgICAgIH07XG4gICAgfVxuICBcbiAgICBsZXQgY3R4ID0ge307XG4gICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcblxuICAgIGlmICghKGNvbXBpbGVyLnNob3VsZENvbXBpbGVGaWxlU3luYyhjb2RlLCBjdHgpKSkge1xuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpLCBkZXBlbmRlbnRGaWxlczogW10gfTtcbiAgICB9XG5cbiAgICBsZXQgZGVwZW5kZW50RmlsZXMgPSBjb21waWxlci5kZXRlcm1pbmVEZXBlbmRlbnRGaWxlc1N5bmMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XG5cbiAgICBsZXQgcmVzdWx0ID0gY29tcGlsZXIuY29tcGlsZVN5bmMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XG5cbiAgICBsZXQgc2hvdWxkSW5saW5lSHRtbGlmeSA9IFxuICAgICAgaW5wdXRNaW1lVHlwZSAhPT0gJ3RleHQvaHRtbCcgJiZcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvaHRtbCc7XG4gICAgICBcbiAgICBsZXQgaXNQYXNzdGhyb3VnaCA9IFxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9wbGFpbicgfHwgXG4gICAgICAhcmVzdWx0Lm1pbWVUeXBlIHx8IFxuICAgICAgQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKTtcbiAgICAgIFxuICAgIGlmICgoZmluYWxGb3Jtc1tyZXN1bHQubWltZVR5cGVdICYmICFzaG91bGRJbmxpbmVIdG1saWZ5KSB8fCBpc1Bhc3N0aHJvdWdoKSB7XG4gICAgICAvLyBHb3Qgc29tZXRoaW5nIHdlIGNhbiB1c2UgaW4tYnJvd3NlciwgbGV0J3MgcmV0dXJuIGl0XG4gICAgICByZXR1cm4gXy5hc3NpZ24ocmVzdWx0LCB7ZGVwZW5kZW50RmlsZXN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZChgUmVjdXJzaXZlbHkgY29tcGlsaW5nIHJlc3VsdCBvZiAke2ZpbGVQYXRofSB3aXRoIG5vbi1maW5hbCBNSU1FIHR5cGUgJHtyZXN1bHQubWltZVR5cGV9LCBpbnB1dCB3YXMgJHtpbnB1dE1pbWVUeXBlfWApO1xuXG4gICAgICBoYXNoSW5mbyA9IF8uYXNzaWduKHsgc291cmNlQ29kZTogcmVzdWx0LmNvZGUsIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSwgaGFzaEluZm8pO1xuICAgICAgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbcmVzdWx0Lm1pbWVUeXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgICAgaWYgKCFjb21waWxlcikge1xuICAgICAgICBkKGBSZWN1cnNpdmUgY29tcGlsZSBmYWlsZWQgLSBpbnRlcm1lZGlhdGUgcmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxpbmcgJHtmaWxlUGF0aH0gcmVzdWx0ZWQgaW4gYSBNSU1FIHR5cGUgb2YgJHtyZXN1bHQubWltZVR5cGV9LCB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZVVuY2FjaGVkU3luYyhcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsIFxuICAgICAgICBoYXNoSW5mbywgY29tcGlsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBpbGVBbGxTeW5jKHJvb3REaXJlY3RvcnksIHNob3VsZENvbXBpbGU9bnVsbCkge1xuICAgIGxldCBzaG91bGQgPSBzaG91bGRDb21waWxlIHx8IGZ1bmN0aW9uKCkge3JldHVybiB0cnVlO307XG5cbiAgICBmb3JBbGxGaWxlc1N5bmMocm9vdERpcmVjdG9yeSwgKGYpID0+IHtcbiAgICAgIGlmICghc2hvdWxkKGYpKSByZXR1cm47XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlU3luYyhmLCB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKlxuICAgKiBPdGhlciBzdHVmZlxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXNzdGhyb3VnaCBjb21waWxlciBcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovICAgXG4gIGdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVsndGV4dC9wbGFpbiddO1xuICB9XG5cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBldmVuIHRyeSB0byBjb21waWxlIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgaW5cbiAgICogc29tZSBjYXNlcywgY29udGVudCB3aWxsIHN0aWxsIGJlIGluIGNhY2hlIGV2ZW4gaWYgdGhpcyByZXR1cm5zIHRydWUsIGFuZFxuICAgKiBpbiBvdGhlciBjYXNlcyAoaXNJbk5vZGVNb2R1bGVzKSwgd2UnbGwga25vdyBleHBsaWNpdGx5IHRvIG5vdCBldmVuIGJvdGhlclxuICAgKiBsb29raW5nIGluIHRoZSBjYWNoZS5cbiAgICogICAgXG4gICAqIEBwcml2YXRlXG4gICAqLyAgIFxuICBzdGF0aWMgc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pIHtcbiAgICByZXR1cm4gaGFzaEluZm8uaXNNaW5pZmllZCB8fCBoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMgfHwgaGFzaEluZm8uaGFzU291cmNlTWFwIHx8IGhhc2hJbmZvLmlzRmlsZUJpbmFyeTtcbiAgfVxufVxuIl19