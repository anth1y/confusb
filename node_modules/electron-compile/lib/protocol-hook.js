'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rigHtmlDocumentToInitializeElectronCompile = rigHtmlDocumentToInitializeElectronCompile;
exports.initializeRendererProcess = initializeRendererProcess;
exports.initializeProtocolHook = initializeProtocolHook;

require('./babel-maybefill');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mimeTypes = require('mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _compilerHost = require('./compiler-host');

var _compilerHost2 = _interopRequireDefault(_compilerHost);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

var magicWords = "__magic__file__to__help__electron__compile.js";
var magicGlobalForRootCacheDir = '__electron_compile_root_cache_dir';
var magicGlobalForAppRootDir = '__electron_compile_app_root_dir';

var d = require('debug')('electron-compile:protocol-hook');

var protocol = null;

/**
 * Adds our script header to the top of all HTML files
 *  
 * @private
 */
function rigHtmlDocumentToInitializeElectronCompile(doc) {
  var lines = doc.split("\n");
  var replacement = '<head><script src="' + magicWords + '"></script>';
  var replacedHead = false;

  for (var i = 0; i < lines.length; i++) {
    if (!lines[i].match(/<head>/i)) continue;

    lines[i] = lines[i].replace(/<head>/i, replacement);
    replacedHead = true;
    break;
  }

  if (!replacedHead) {
    replacement = '<html$1><head><script src="' + magicWords + '"></script></head>';
    for (var i = 0; i < lines.length; i++) {
      if (!lines[i].match(/<html/i)) continue;

      lines[i] = lines[i].replace(/<html([^>]+)>/i, replacement);
      break;
    }
  }

  return lines.join("\n");
}

function requestFileJob(filePath, finish) {
  _fs2.default.readFile(filePath, function (err, buf) {
    if (err) {
      if (err.errno === 34) {
        finish(-6); // net::ERR_FILE_NOT_FOUND
        return;
      } else {
        finish(-2); // net::FAILED
        return;
      }
    }

    finish({
      data: buf,
      mimeType: _mimeTypes2.default.lookup(filePath) || 'text/plain'
    });
  });
}

var rendererInitialized = false;

/**
 * Called by our rigged script file at the top of every HTML file to set up
 * the same compilers as the browser process that created us
 *  
 * @private
 */
function initializeRendererProcess(readOnlyMode) {
  if (rendererInitialized) return;

  // NB: If we don't do this, we'll get a renderer crash if you enable debug
  require('debug/browser');

  var rootCacheDir = require('remote').getGlobal(magicGlobalForRootCacheDir);
  var appRoot = require('remote').getGlobal(magicGlobalForAppRootDir);
  var compilerHost = null;

  // NB: This has to be synchronous because we need to block HTML parsing
  // until we're set up
  if (readOnlyMode) {
    d('Setting up electron-compile in precompiled mode with cache dir: ' + rootCacheDir);
    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);
  } else {
    d('Setting up electron-compile in development mode with cache dir: ' + rootCacheDir);

    var _require = require('./config-parser');

    var createCompilers = _require.createCompilers;

    var compilersByMimeType = createCompilers();

    compilerHost = _compilerHost2.default.createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType);
  }

  require('./x-require');
  require('./require-hook').default(compilerHost);
  rendererInitialized = true;
}

/**
 * Initializes the protocol hook on file: that allows us to intercept files 
 * loaded by Chromium and rewrite them. This method along with 
 * {@link registerRequireExtension} are the top-level methods that electron-compile
 * actually uses to intercept code that Electron loads.
 *  
 * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.
 */
function initializeProtocolHook(compilerHost) {
  protocol = protocol || require('protocol');

  global[magicGlobalForRootCacheDir] = compilerHost.rootCacheDir;
  global[magicGlobalForAppRootDir] = compilerHost.appRoot;

  var electronCompileSetupCode = 'if (window.require) require(\'electron-compile/lib/protocol-hook\').initializeRendererProcess(' + compilerHost.readOnlyMode + ');';

  protocol.interceptBufferProtocol('file', function () {
    var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request, finish) {
      var uri, filePath, result, err;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              uri = _url2.default.parse(request.url);

              d('Intercepting url ' + request.url);

              if (!(request.url.indexOf(magicWords) > -1)) {
                _context.next = 5;
                break;
              }

              finish({
                mimeType: 'application/javascript',
                data: new Buffer(electronCompileSetupCode, 'utf8')
              });

              return _context.abrupt('return');

            case 5:

              // This is a protocol-relative URL that has gone pear-shaped in Electron,
              // let's rewrite it
              if (uri.host && uri.host.length > 1) {
                //let newUri = request.url.replace(/^file:/, "https:");
                // TODO: Jump off this bridge later
                d('TODO: Found bogus protocol-relative URL, can\'t fix it up!!');
                finish(-2);
              }

              filePath = decodeURIComponent(uri.pathname);

              // NB: pathname has a leading '/' on Win32 for some reason

              if (process.platform === 'win32') {
                filePath = filePath.slice(1);
              }

              // NB: Special-case files coming from atom.asar or node_modules

              if (!(filePath.match(/[\/\\]atom.asar/) || filePath.match(/[\/\\]node_modules/))) {
                _context.next = 11;
                break;
              }

              requestFileJob(filePath, finish);
              return _context.abrupt('return');

            case 11:
              _context.prev = 11;
              _context.next = 14;
              return compilerHost.compile(filePath);

            case 14:
              result = _context.sent;

              if (result.mimeType === 'text/html') {
                result.code = rigHtmlDocumentToInitializeElectronCompile(result.code);
              }

              if (!(result.binaryData || result.code instanceof Buffer)) {
                _context.next = 21;
                break;
              }

              finish({ data: result.binaryData || result.code, mimeType: result.mimeType });
              return _context.abrupt('return');

            case 21:
              finish({ data: new Buffer(result.code), mimeType: result.mimeType });
              return _context.abrupt('return');

            case 23:
              _context.next = 34;
              break;

            case 25:
              _context.prev = 25;
              _context.t0 = _context['catch'](11);
              err = 'Failed to compile ' + filePath + ': ' + _context.t0.message + '\n' + _context.t0.stack;

              d(err);

              if (!(_context.t0.errno === 34 /*ENOENT*/)) {
                _context.next = 32;
                break;
              }

              finish(-6); // net::ERR_FILE_NOT_FOUND
              return _context.abrupt('return');

            case 32:

              finish({ mimeType: 'text/plain', data: new Buffer(err) });
              return _context.abrupt('return');

            case 34:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this, [[11, 25]]);
    }));

    return function (_x, _x2) {
      return ref.apply(this, arguments);
    };
  }());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm90b2NvbC1ob29rLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O1FBb0JnQjtRQXFEQTtRQXFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdkdoQixJQUFNLGFBQWEsK0NBQWI7QUFDTixJQUFNLDZCQUE2QixtQ0FBN0I7QUFDTixJQUFNLDJCQUEyQixpQ0FBM0I7O0FBRU4sSUFBTSxJQUFJLFFBQVEsT0FBUixFQUFpQixnQ0FBakIsQ0FBSjs7QUFFTixJQUFJLFdBQVcsSUFBWDs7Ozs7OztBQU9HLFNBQVMsMENBQVQsQ0FBb0QsR0FBcEQsRUFBeUQ7QUFDOUQsTUFBSSxRQUFRLElBQUksS0FBSixDQUFVLElBQVYsQ0FBUixDQUQwRDtBQUU5RCxNQUFJLHNDQUFvQywwQkFBcEMsQ0FGMEQ7QUFHOUQsTUFBSSxlQUFlLEtBQWYsQ0FIMEQ7O0FBSzlELE9BQUssSUFBSSxJQUFFLENBQUYsRUFBSyxJQUFJLE1BQU0sTUFBTixFQUFjLEdBQWhDLEVBQXFDO0FBQ25DLFFBQUksQ0FBQyxNQUFNLENBQU4sRUFBUyxLQUFULENBQWUsU0FBZixDQUFELEVBQTRCLFNBQWhDOztBQUVBLFVBQU0sQ0FBTixJQUFXLEtBQUMsQ0FBTSxDQUFOLENBQUQsQ0FBVyxPQUFYLENBQW1CLFNBQW5CLEVBQThCLFdBQTlCLENBQVgsQ0FIbUM7QUFJbkMsbUJBQWUsSUFBZixDQUptQztBQUtuQyxVQUxtQztHQUFyQzs7QUFRQSxNQUFJLENBQUMsWUFBRCxFQUFlO0FBQ2pCLGtEQUE0QyxpQ0FBNUMsQ0FEaUI7QUFFakIsU0FBSyxJQUFJLElBQUUsQ0FBRixFQUFLLElBQUksTUFBTSxNQUFOLEVBQWMsR0FBaEMsRUFBcUM7QUFDbkMsVUFBSSxDQUFDLE1BQU0sQ0FBTixFQUFTLEtBQVQsQ0FBZSxRQUFmLENBQUQsRUFBMkIsU0FBL0I7O0FBRUEsWUFBTSxDQUFOLElBQVcsS0FBQyxDQUFNLENBQU4sQ0FBRCxDQUFXLE9BQVgsQ0FBbUIsZ0JBQW5CLEVB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QywyQkFBVyxTQUFTLEtBQVQsQ0FBZSxDQUFmLENBQVgsQ0FEZ0M7ZUFBbEM7Ozs7b0JBS0ksU0FBUyxLQUFULENBQWUsaUJBQWYsS0FBcUMsU0FBUyxLQUFULENBQWUsb0JBQWYsQ0FBckM7Ozs7O0FBQ0YsNkJBQWUsUUFBZixFQUF5QixNQUF6Qjs7Ozs7O3FCQUttQixhQUFhLE9BQWIsQ0FBcUIsUUFBckI7OztBQUFmOztBQUVKLGtCQUFJLE9BQU8sUUFBUCxLQUFvQixXQUFwQixFQUFpQztBQUNuQyx1QkFBTyxJQUFQLEdBQWMsMkNBQTJDLE9BQU8sSUFBUCxDQUF6RCxDQURtQztlQUFyQzs7b0JBSUksT0FBTyxVQUFQLElBQXFCLE9BQU8sSUFBUCxZQUF1QixNQUF2Qjs7Ozs7QUFDdkIscUJBQU8sRUFBRSxNQUFNLE9BQU8sVUFBUCxJQUFxQixPQUFPLElBQVAsRUFBYSxVQUFVLE9BQU8sUUFBUCxFQUEzRDs7OztBQUdBLHFCQUFPLEVBQUUsTUFBTSxJQUFJLE1BQUosQ0FBVyxPQUFPLElBQVAsQ0FBakIsRUFBK0IsVUFBVSxPQUFPLFFBQVAsRUFBbEQ7Ozs7Ozs7Ozs7QUFJRSwyQ0FBMkIsa0JBQWEsWUFBRSxPQUFGLFVBQWMsWUFBRSxLQUFGOztBQUMxRCxnQkFBRSxHQUFGOztvQkFFSSxZQUFFLEtBQUYsS0FBWSxFQUFaOzs7OztBQUNGLHFCQUFPLENBQUMsQ0FBRCxDQUFQOzs7OztBQUlGLHFCQUFPLEVBQUUsVUFBVSxZQUFWLEVBQXdCLE1BQU0sSUFBSSxNQUFKLENBQVcsR0FBWCxDQUFOLEVBQWpDOzs7Ozs7Ozs7S0ExRHFDOzs7OztLQUF6QyxFQVJtRDtDQUE5QyIsImZpbGUiOiJwcm90b2NvbC1ob29rLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2JhYmVsLW1heWJlZmlsbCc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IG1pbWUgZnJvbSAnbWltZS10eXBlcyc7XG5cbmltcG9ydCBDb21waWxlckhvc3QgZnJvbSAnLi9jb21waWxlci1ob3N0JztcblxuY29uc3QgbWFnaWNXb3JkcyA9IFwiX19tYWdpY19fZmlsZV9fdG9fX2hlbHBfX2VsZWN0cm9uX19jb21waWxlLmpzXCI7XG5jb25zdCBtYWdpY0dsb2JhbEZvclJvb3RDYWNoZURpciA9ICdfX2VsZWN0cm9uX2NvbXBpbGVfcm9vdF9jYWNoZV9kaXInO1xuY29uc3QgbWFnaWNHbG9iYWxGb3JBcHBSb290RGlyID0gJ19fZWxlY3Ryb25fY29tcGlsZV9hcHBfcm9vdF9kaXInO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpwcm90b2NvbC1ob29rJyk7XG5cbmxldCBwcm90b2NvbCA9IG51bGw7XG5cbi8qKlxuICogQWRkcyBvdXIgc2NyaXB0IGhlYWRlciB0byB0aGUgdG9wIG9mIGFsbCBIVE1MIGZpbGVzXG4gKiAgXG4gKiBAcHJpdmF0ZVxuICovIFxuZXhwb3J0IGZ1bmN0aW9uIHJpZ0h0bWxEb2N1bWVudFRvSW5pdGlhbGl6ZUVsZWN0cm9uQ29tcGlsZShkb2MpIHtcbiAgbGV0IGxpbmVzID0gZG9jLnNwbGl0KFwiXFxuXCIpO1xuICBsZXQgcmVwbGFjZW1lbnQgPSBgPGhlYWQ+PHNjcmlwdCBzcmM9XCIke21hZ2ljV29yZHN9XCI+PC9zY3JpcHQ+YDtcbiAgbGV0IHJlcGxhY2VkSGVhZCA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGk9MDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFsaW5lc1tpXS5tYXRjaCgvPGhlYWQ+L2kpKSBjb250aW51ZTtcblxuICAgIGxpbmVzW2ldID0gKGxpbmVzW2ldKS5yZXBsYWNlKC88aGVhZD4vaSwgcmVwbGFjZW1lbnQpO1xuICAgIHJlcGxhY2VkSGVhZCA9IHRydWU7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZiAoIXJlcGxhY2VkSGVhZCkge1xuICAgIHJlcGxhY2VtZW50ID0gYDxodG1sJDE+PGhlYWQ+PHNjcmlwdCBzcmM9XCIke21hZ2ljV29yZHN9XCI+PC9zY3JpcHQ+PC9oZWFkPmA7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghbGluZXNbaV0ubWF0Y2goLzxodG1sL2kpKSBjb250aW51ZTtcblxuICAgICAgbGluZXNbaV0gPSAobGluZXNbaV0pLnJlcGxhY2UoLzxodG1sKFtePl0rKT4vaSwgcmVwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RGaWxlSm9iKGZpbGVQYXRoLCBmaW5pc2gpIHtcbiAgZnMucmVhZEZpbGUoZmlsZVBhdGgsIChlcnIsIGJ1ZikgPT4ge1xuICAgIGlmIChlcnIpIHsgXG4gICAgICBpZiAoZXJyLmVycm5vID09PSAzNCkge1xuICAgICAgICBmaW5pc2goLTYpOyAvLyBuZXQ6OkVSUl9GSUxFX05PVF9GT1VORFxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2goLTIpOyAvLyBuZXQ6OkZBSUxFRFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZpbmlzaCh7XG4gICAgICBkYXRhOiBidWYsXG4gICAgICBtaW1lVHlwZTogbWltZS5sb29rdXAoZmlsZVBhdGgpIHx8ICd0ZXh0L3BsYWluJ1xuICAgIH0pO1xuICB9KTtcbn1cblxubGV0IHJlbmRlcmVySW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBDYWxsZWQgYnkgb3VyIHJpZ2dlZCBzY3JpcHQgZmlsZSBhdCB0aGUgdG9wIG9mIGV2ZXJ5IEhUTUwgZmlsZSB0byBzZXQgdXBcbiAqIHRoZSBzYW1lIGNvbXBpbGVycyBhcyB0aGUgYnJvd3NlciBwcm9jZXNzIHRoYXQgY3JlYXRlZCB1c1xuICogIFxuICogQHByaXZhdGVcbiAqLyBcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplUmVuZGVyZXJQcm9jZXNzKHJlYWRPbmx5TW9kZSkge1xuICBpZiAocmVuZGVyZXJJbml0aWFsaXplZCkgcmV0dXJuO1xuICBcbiAgLy8gTkI6IElmIHdlIGRvbid0IGRvIHRoaXMsIHdlJ2xsIGdldCBhIHJlbmRlcmVyIGNyYXNoIGlmIHlvdSBlbmFibGUgZGVidWdcbiAgcmVxdWlyZSgnZGVidWcvYnJvd3NlcicpO1xuICBcbiAgbGV0IHJvb3RDYWNoZURpciA9IHJlcXVpcmUoJ3JlbW90ZScpLmdldEdsb2JhbChtYWdpY0dsb2JhbEZvclJvb3RDYWNoZURpcik7XG4gIGxldCBhcHBSb290ID0gcmVxdWlyZSgncmVtb3RlJykuZ2V0R2xvYmFsKG1hZ2ljR2xvYmFsRm9yQXBwUm9vdERpcik7XG4gIGxldCBjb21waWxlckhvc3QgPSBudWxsO1xuICBcbiAgLy8gTkI6IFRoaXMgaGFzIHRvIGJlIHN5bmNocm9ub3VzIGJlY2F1c2Ugd2UgbmVlZCB0byBibG9jayBIVE1MIHBhcnNpbmdcbiAgLy8gdW50aWwgd2UncmUgc2V0IHVwXG4gIGlmIChyZWFkT25seU1vZGUpIHtcbiAgICBkKGBTZXR0aW5nIHVwIGVsZWN0cm9uLWNvbXBpbGUgaW4gcHJlY29tcGlsZWQgbW9kZSB3aXRoIGNhY2hlIGRpcjogJHtyb290Q2FjaGVEaXJ9YCk7XG4gICAgY29tcGlsZXJIb3N0ID0gQ29tcGlsZXJIb3N0LmNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgZChgU2V0dGluZyB1cCBlbGVjdHJvbi1jb21waWxlIGluIGRldmVsb3BtZW50IG1vZGUgd2l0aCBjYWNoZSBkaXI6ICR7cm9vdENhY2hlRGlyfWApO1xuICAgIGNvbnN0IHsgY3JlYXRlQ29tcGlsZXJzIH0gPSByZXF1aXJlKCcuL2NvbmZpZy1wYXJzZXInKTtcbiAgICBjb25zdCBjb21waWxlcnNCeU1pbWVUeXBlID0gY3JlYXRlQ29tcGlsZXJzKCk7XG4gICAgXG4gICAgY29tcGlsZXJIb3N0ID0gQ29tcGlsZXJIb3N0LmNyZWF0ZUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGNvbXBpbGVyc0J5TWltZVR5cGUpO1xuICB9XG4gIFxuICByZXF1aXJlKCcuL3gtcmVxdWlyZScpO1xuICByZXF1aXJlKCcuL3JlcXVpcmUtaG9vaycpLmRlZmF1bHQoY29tcGlsZXJIb3N0KTtcbiAgcmVuZGVyZXJJbml0aWFsaXplZCA9IHRydWU7XG59XG5cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgcHJvdG9jb2wgaG9vayBvbiBmaWxlOiB0aGF0IGFsbG93cyB1cyB0byBpbnRlcmNlcHQgZmlsZXMgXG4gKiBsb2FkZWQgYnkgQ2hyb21pdW0gYW5kIHJld3JpdGUgdGhlbS4gVGhpcyBtZXRob2QgYWxvbmcgd2l0aCBcbiAqIHtAbGluayByZWdpc3RlclJlcXVpcmVFeHRlbnNpb259IGFyZSB0aGUgdG9wLWxldmVsIG1ldGhvZHMgdGhhdCBlbGVjdHJvbi1jb21waWxlXG4gKiBhY3R1YWxseSB1c2VzIHRvIGludGVyY2VwdCBjb2RlIHRoYXQgRWxlY3Ryb24gbG9hZHMuXG4gKiAgXG4gKiBAcGFyYW0gIHtDb21waWxlckhvc3R9IGNvbXBpbGVySG9zdCAgVGhlIGNvbXBpbGVyIGhvc3QgdG8gdXNlIGZvciBjb21waWxhdGlvbi5cbiAqLyBcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplUHJvdG9jb2xIb29rKGNvbXBpbGVySG9zdCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sIHx8IHJlcXVpcmUoJ3Byb3RvY29sJyk7XG4gIFxuICBnbG9iYWxbbWFnaWNHbG9iYWxGb3JSb290Q2FjaGVEaXJdID0gY29tcGlsZXJIb3N0LnJvb3RDYWNoZURpcjtcbiAgZ2xvYmFsW21hZ2ljR2xvYmFsRm9yQXBwUm9vdERpcl0gPSBjb21waWxlckhvc3QuYXBwUm9vdDtcbiAgXG4gIGNvbnN0IGVsZWN0cm9uQ29tcGlsZVNldHVwQ29kZSA9IGBpZiAod2luZG93LnJlcXVpcmUpIHJlcXVpcmUoJ2VsZWN0cm9uLWNvbXBpbGUvbGliL3Byb3RvY29sLWhvb2snKS5pbml0aWFsaXplUmVuZGVyZXJQcm9jZXNzKCR7Y29tcGlsZXJIb3N0LnJlYWRPbmx5TW9kZX0pO2A7XG5cbiAgcHJvdG9jb2wuaW50ZXJjZXB0QnVmZmVyUHJvdG9jb2woJ2ZpbGUnLCBhc3luYyBmdW5jdGlvbihyZXF1ZXN0LCBmaW5pc2gpIHtcbiAgICBsZXQgdXJpID0gdXJsLnBhcnNlKHJlcXVlc3QudXJsKTtcblxuICAgIGQoYEludGVyY2VwdGluZyB1cmwgJHtyZXF1ZXN0LnVybH1gKTtcbiAgICBpZiAocmVxdWVzdC51cmwuaW5kZXhPZihtYWdpY1dvcmRzKSA+IC0xKSB7XG4gICAgICBmaW5pc2goe1xuICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICAgICAgICBkYXRhOiBuZXcgQnVmZmVyKGVsZWN0cm9uQ29tcGlsZVNldHVwQ29kZSwgJ3V0ZjgnKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIHRoYXQgaGFzIGdvbmUgcGVhci1zaGFwZWQgaW4gRWxlY3Ryb24sXG4gICAgLy8gbGV0J3MgcmV3cml0ZSBpdFxuICAgIGlmICh1cmkuaG9zdCAmJiB1cmkuaG9zdC5sZW5ndGggPiAxKSB7XG4gICAgICAvL2xldCBuZXdVcmkgPSByZXF1ZXN0LnVybC5yZXBsYWNlKC9eZmlsZTovLCBcImh0dHBzOlwiKTtcbiAgICAgIC8vIFRPRE86IEp1bXAgb2ZmIHRoaXMgYnJpZGdlIGxhdGVyXG4gICAgICBkKGBUT0RPOiBGb3VuZCBib2d1cyBwcm90b2NvbC1yZWxhdGl2ZSBVUkwsIGNhbid0IGZpeCBpdCB1cCEhYCk7XG4gICAgICBmaW5pc2goLTIpO1xuICAgIH1cblxuICAgIGxldCBmaWxlUGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmkucGF0aG5hbWUpO1xuXG4gICAgLy8gTkI6IHBhdGhuYW1lIGhhcyBhIGxlYWRpbmcgJy8nIG9uIFdpbjMyIGZvciBzb21lIHJlYXNvblxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICBmaWxlUGF0aCA9IGZpbGVQYXRoLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIC8vIE5COiBTcGVjaWFsLWNhc2UgZmlsZXMgY29taW5nIGZyb20gYXRvbS5hc2FyIG9yIG5vZGVfbW9kdWxlc1xuICAgIGlmIChmaWxlUGF0aC5tYXRjaCgvW1xcL1xcXFxdYXRvbS5hc2FyLykgfHwgZmlsZVBhdGgubWF0Y2goL1tcXC9cXFxcXW5vZGVfbW9kdWxlcy8pKSB7XG4gICAgICByZXF1ZXN0RmlsZUpvYihmaWxlUGF0aCwgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb21waWxlckhvc3QuY29tcGlsZShmaWxlUGF0aCk7XG5cbiAgICAgIGlmIChyZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L2h0bWwnKSB7XG4gICAgICAgIHJlc3VsdC5jb2RlID0gcmlnSHRtbERvY3VtZW50VG9Jbml0aWFsaXplRWxlY3Ryb25Db21waWxlKHJlc3VsdC5jb2RlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdC5iaW5hcnlEYXRhIHx8IHJlc3VsdC5jb2RlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGZpbmlzaCh7IGRhdGE6IHJlc3VsdC5iaW5hcnlEYXRhIHx8IHJlc3VsdC5jb2RlLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2goeyBkYXRhOiBuZXcgQnVmZmVyKHJlc3VsdC5jb2RlKSwgbWltZVR5cGU6IHJlc3VsdC5taW1lVHlwZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxldCBlcnIgPSBgRmFpbGVkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH06ICR7ZS5tZXNzYWdlfVxcbiR7ZS5zdGFja31gO1xuICAgICAgZChlcnIpO1xuICAgICAgXG4gICAgICBpZiAoZS5lcnJubyA9PT0gMzQgLypFTk9FTlQqLykge1xuICAgICAgICBmaW5pc2goLTYpOyAvLyBuZXQ6OkVSUl9GSUxFX05PVF9GT1VORFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZpbmlzaCh7IG1pbWVUeXBlOiAndGV4dC9wbGFpbicsIGRhdGE6IG5ldyBCdWZmZXIoZXJyKSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xufVxuIl19