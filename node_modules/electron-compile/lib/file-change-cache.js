'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _promise = require('./promise');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sanitizePaths = require('./sanitize-paths');

var _sanitizePaths2 = _interopRequireDefault(_sanitizePaths);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var d = require('debug')('electron-compile:file-change-cache');

/**
 * This class caches information about files and determines whether they have
 * changed contents or not. Most importantly, this class caches the hash of seen
 * files so that at development time, we don't have to recalculate them constantly.
 * 
 * This class is also the core of how electron-compile runs quickly in production
 * mode - after precompilation, the cache is serialized along with the rest of the
 * data in {@link CompilerHost}, so that when we load the app in production mode,
 * we don't end up calculating hashes of file content at all, only using the contents
 * of this cache.
 */

var FileChangedCache = function () {
  function FileChangedCache(appRoot) {
    var failOnCacheMiss = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    _classCallCheck(this, FileChangedCache);

    this.appRoot = (0, _sanitizePaths2.default)(appRoot);
    this.failOnCacheMiss = failOnCacheMiss;
    this.changeCache = {};
  }

  /**  
   * Allows you to create a FileChangedCache from serialized data saved from 
   * {@link getSavedData}.
   *    
   * @param  {Object} data  Saved data from getSavedData.
   * 
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   * 
   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
   * 
   * @return {FileChangedCache}
   */

  _createClass(FileChangedCache, [{
    key: 'getHashForPath',

    /**  
     * Returns information about a given file, including its hash. This method is
     * the main method for this cache.
     *    
     * @param  {string} absoluteFilePath  The path to a file to retrieve info on.
     * 
     * @return {Promise<Object>}
     * 
     * @property {string} hash  The SHA1 hash of the file
     * @property {boolean} isMinified  True if the file is minified
     * @property {boolean} isInNodeModules  True if the file is in a library directory
     * @property {boolean} hasSourceMap  True if the file has a source map
     * @property {boolean} isFileBinary  True if the file is not a text file
     * @property {Buffer} binaryData (optional)  The buffer that was read if the file
     *                                           was binary and there was a cache miss.
     * @property {string} code (optional)  The string that was read if the file
     *                                     was text and there was a cache miss
     */
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(absoluteFilePath) {
        var cacheKey, cacheEntry, stat, ctime, size, _ref, digest, sourceCode, binaryData, info;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);

                if (this.appRoot) {
                  cacheKey = cacheKey.replace(this.appRoot, '');
                }

                // NB: We do this because x-require will include an absolute path from the
                // original built app and we need to still grok it
                if (this.originalAppRoot) {
                  cacheKey = cacheKey.replace(this.originalAppRoot, '');
                }

                cacheEntry = this.changeCache[cacheKey];

                if (!this.failOnCacheMiss) {
                  _context.next = 10;
                  break;
                }

                if (cacheEntry) {
                  _context.next = 9;
                  break;
                }

                d('Tried to read file cache entry for ' + absoluteFilePath);
                d('cacheKey: ' + cacheKey + ', appRoot: ' + this.appRoot + ', originalAppRoot: ' + this.originalAppRoot);
                throw new Error('Asked for ' + absoluteFilePath + ' but it was not precompiled!');

              case 9:
                return _context.abrupt('return', cacheEntry.info);

              case 10:
                _context.next = 12;
                return _promise.pfs.stat(absoluteFilePath);

              case 12:
                stat = _context.sent;
                ctime = stat.ctime.getTime();
                size = stat.size;

                if (!(!stat || !stat.isFile())) {
                  _context.next = 17;
                  break;
                }

                throw new Error('Can\'t stat ' + absoluteFilePath);

              case 17:
                if (!cacheEntry) {
                  _context.next = 22;
                  break;
                }

                if (!(cacheEntry.ctime >= ctime && cacheEntry.size === size)) {
                  _context.next = 20;
                  break;
                }

                return _context.abrupt('return', cacheEntry.info);

              case 20:

                d('Invalidating cache entry: ' + cacheEntry.ctime + ' === ' + ctime + ' && ' + cacheEntry.size + ' === ' + size);
                delete this.changeCache.cacheEntry;

              case 22:
                _context.next = 24;
                return this.calculateHashForFile(absoluteFilePath);

              case 24:
                _ref = _context.sent;
                digest = _ref.digest;
                sourceCode = _ref.sourceCode;
                binaryData = _ref.binaryData;
                info = {
                  hash: digest,
                  isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
                  isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
                  hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
                  isFileBinary: !!binaryData
                };

                this.changeCache[cacheKey] = { ctime: ctime, size: size, info: info };
                d('Cache entry for ' + cacheKey + ': ' + JSON.stringify(this.changeCache[cacheKey]));

                if (!binaryData) {
                  _context.next = 35;
                  break;
                }

                return _context.abrupt('return', _lodash2.default.extend({ binaryData: binaryData }, info));

              case 35:
                return _context.abrupt('return', _lodash2.default.extend({ sourceCode: sourceCode }, info));

              case 36:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function getHashForPath(_x2) {
        return ref.apply(this, arguments);
      };
    }()

    /**  
     * Returns data that can passed to {@link loadFromData} to rehydrate this cache.
     *    
     * @return {Object}
     */

  }, {
    key: 'getSavedData',
    value: function getSavedData() {
      return { changeCache: this.changeCache, appRoot: this.appRoot };
    }

    /**  
     * Serializes this object's data to a file.
     *
     * @param {string} filePath  The path to save data to.
     *    
     * @return {Promise} Completion.
     */

  }, {
    key: 'save',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(filePath) {
        var toSave, buf;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                toSave = this.getSavedData();
                _context2.next = 3;
                return _promise.pzlib.gzip(new Buffer(JSON.stringify(toSave)));

              case 3:
                buf = _context2.sent;
                _context2.next = 6;
                return _promise.pfs.writeFile(filePath, buf);

              case 6:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function save(_x3) {
        return ref.apply(this, arguments);
      };
    }()
  }, {
    key: 'calculateHashForFile',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(absoluteFilePath) {
        var buf, encoding, _digest, sourceCode, digest;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _promise.pfs.readFile(absoluteFilePath);

              case 2:
                buf = _context3.sent;
                encoding = FileChangedCache.detectFileEncoding(buf);

                if (encoding) {
                  _context3.next = 7;
                  break;
                }

                _digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');
                return _context3.abrupt('return', { sourceCode: null, digest: _digest, binaryData: buf });

              case 7:
                _context3.next = 9;
                return _promise.pfs.readFile(absoluteFilePath, encoding);

              case 9:
                sourceCode = _context3.sent;
                digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');
                return _context3.abrupt('return', { sourceCode: sourceCode, digest: digest, binaryData: null });

              case 12:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function calculateHashForFile(_x4) {
        return ref.apply(this, arguments);
      };
    }()
  }, {
    key: 'getHashForPathSync',
    value: function getHashForPathSync(absoluteFilePath) {
      var cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);
      if (this.appRoot) {
        cacheKey = cacheKey.replace(this.appRoot, '');
      }

      // NB: We do this because x-require will include an absolute path from the
      // original built app and we need to still grok it
      if (this.originalAppRoot) {
        cacheKey = cacheKey.replace(this.originalAppRoot, '');
      }

      var cacheEntry = this.changeCache[cacheKey];

      if (this.failOnCacheMiss) {
        if (!cacheEntry) {
          d('Tried to read file cache entry for ' + absoluteFilePath);
          d('cacheKey: ' + cacheKey + ', appRoot: ' + this.appRoot + ', originalAppRoot: ' + this.originalAppRoot);
          throw new Error('Asked for ' + absoluteFilePath + ' but it was not precompiled!');
        }

        return cacheEntry.info;
      }

      var stat = _fs2.default.statSync(absoluteFilePath);
      var ctime = stat.ctime.getTime();
      var size = stat.size;
      if (!stat || !stat.isFile()) throw new Error('Can\'t stat ' + absoluteFilePath);

      if (cacheEntry) {
        if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {
          return cacheEntry.info;
        }

        d('Invalidating cache entry: ' + cacheEntry.ctime + ' === ' + ctime + ' && ' + cacheEntry.size + ' === ' + size);
        delete this.changeCache.cacheEntry;
      }

      var _calculateHashForFile = this.calculateHashForFileSync(absoluteFilePath);

      var digest = _calculateHashForFile.digest;
      var sourceCode = _calculateHashForFile.sourceCode;
      var binaryData = _calculateHashForFile.binaryData;

      var info = {
        hash: digest,
        isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
        isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
        hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
        isFileBinary: !!binaryData
      };

      this.changeCache[cacheKey] = { ctime: ctime, size: size, info: info };
      d('Cache entry for ' + cacheKey + ': ' + JSON.stringify(this.changeCache[cacheKey]));

      if (binaryData) {
        return _lodash2.default.extend({ binaryData: binaryData }, info);
      } else {
        return _lodash2.default.extend({ sourceCode: sourceCode }, info);
      }
    }
  }, {
    key: 'saveSync',
    value: function saveSync(filePath) {
      var toSave = this.getSavedData();

      var buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(toSave)));
      _fs2.default.writeFileSync(filePath, buf);
    }
  }, {
    key: 'calculateHashForFileSync',
    value: function calculateHashForFileSync(absoluteFilePath) {
      var buf = _fs2.default.readFileSync(absoluteFilePath);
      var encoding = FileChangedCache.detectFileEncoding(buf);

      if (!encoding) {
        var _digest2 = _crypto2.default.createHash('sha1').update(buf).digest('hex');
        return { sourceCode: null, digest: _digest2, binaryData: buf };
      }

      var sourceCode = _fs2.default.readFileSync(absoluteFilePath, encoding);
      var digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');

      return { sourceCode: sourceCode, digest: digest, binaryData: null };
    }

    /**  
     * Determines via some statistics whether a file is likely to be minified.
     *
     * @private
     */

  }], [{
    key: 'loadFromData',
    value: function loadFromData(data, appRoot) {
      var failOnCacheMiss = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

      var ret = new FileChangedCache(appRoot, failOnCacheMiss);
      ret.changeCache = data.changeCache;
      ret.originalAppRoot = data.appRoot;

      return ret;
    }

    /**  
     * Allows you to create a FileChangedCache from serialized data saved from 
     * {@link save}.
     *    
     * @param  {string} file  Saved data from save.
     * 
     * @param  {string} appRoot  The top-level directory for your application (i.e.
     *                           the one which has your package.json).
     * 
     * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
     * 
     * @return {Promise<FileChangedCache>}
     */

  }, {
    key: 'loadFromFile',
    value: function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(file, appRoot) {
        var failOnCacheMiss = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
        var buf;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                d('Loading canned FileChangedCache from ' + file);

                _context4.next = 3;
                return _promise.pfs.readFile(file);

              case 3:
                buf = _context4.sent;
                _context4.t0 = FileChangedCache;
                _context4.t1 = JSON;
                _context4.next = 8;
                return _promise.pzlib.gunzip(buf);

              case 8:
                _context4.t2 = _context4.sent;
                _context4.t3 = _context4.t1.parse.call(_context4.t1, _context4.t2);
                _context4.t4 = appRoot;
                _context4.t5 = failOnCacheMiss;
                return _context4.abrupt('return', _context4.t0.loadFromData.call(_context4.t0, _context4.t3, _context4.t4, _context4.t5));

              case 13:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function loadFromFile(_x7, _x8) {
        return ref.apply(this, arguments);
      };
    }()
  }, {
    key: 'contentsAreMinified',
    value: function contentsAreMinified(source) {
      var length = source.length;
      if (length > 1024) length = 1024;

      var newlineCount = 0;

      // Roll through the characters and determine the average line length
      for (var i = 0; i < source.length; i++) {
        if (source[i] === '\n') newlineCount++;
      }

      // No Newlines? Any file other than a super small one is minified
      if (newlineCount === 0) {
        return length > 80;
      }

      var avgLineLength = length / newlineCount;
      return avgLineLength > 80;
    }

    /**  
     * Determines whether a path is in node_modules or the Electron init code
     *    
     * @private
     */

  }, {
    key: 'isInNodeModules',
    value: function isInNodeModules(filePath) {
      return !!(filePath.match(/node_modules[\\\/]/i) || filePath.match(/atom\.asar/));
    }

    /**
     * Returns whether a file has an inline source map
     *    
     * @private
     */

  }, {
    key: 'hasSourceMap',
    value: function hasSourceMap(sourceCode) {
      return sourceCode.lastIndexOf('//# sourceMap') > sourceCode.lastIndexOf('\n');
    }

    /**  
     * Determines the encoding of a file from the two most common encodings by trying
     * to decode it then looking for encoding errors
     *
     * @private
     */

  }, {
    key: 'detectFileEncoding',
    value: function detectFileEncoding(buffer) {
      if (buffer.length < 1) return false;
      var buf = buffer.length < 4096 ? buffer : buffer.slice(0, 4096);

      var encodings = ['utf8', 'utf16le'];

      var encoding = _lodash2.default.find(encodings, function (x) {
        return !FileChangedCache.containsControlCharacters(buf.toString(x));
      });

      return encoding;
    }

    /**  
     * Determines whether a string is likely to be poorly encoded by looking for
     * control characters above a certain threshold
     *
     * @private
     */

  }, {
    key: 'containsControlCharacters',
    value: function containsControlCharacters(str) {
      var controlCount = 0;
      var threshold = str.length < 64 ? 2 : 16;

      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c === 65536 || c < 8) controlCount++;

        if (controlCount > threshold) return true;
      }

      if (controlCount === 0) return false;
      return controlCount / str.length < 0.02;
    }
  }]);

  return FileChangedCache;
}();

exports.default = FileChangedCache;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWNoYW5nZS1jYWNoZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQSxJQUFNLElBQUksUUFBUSxPQUFSLEVBQWlCLG9DQUFqQixDQUFKOzs7Ozs7Ozs7Ozs7OztJQWFlO0FBQ25CLFdBRG1CLGdCQUNuQixDQUFZLE9BQVosRUFBNEM7UUFBdkIsd0VBQWdCLHFCQUFPOzswQkFEekIsa0JBQ3lCOztBQUMxQyxTQUFLLE9BQUwsR0FBZSw2QkFBaUIsT0FBakIsQ0FBZixDQUQwQztBQUUxQyxTQUFLLGVBQUwsR0FBdUIsZUFBdkIsQ0FGMEM7QUFHMUMsU0FBSyxXQUFMLEdBQW1CLEVBQW5CLENBSDBDO0dBQTVDOzs7Ozs7Ozs7Ozs7Ozs7O2VBRG1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJFQW9FRTtZQUNmLFVBV0EsWUFZQSxNQUNBLE9BQ0EsWUFZQyxRQUFRLFlBQVksWUFFckI7Ozs7OztBQXZDQSwyQkFBVyw2QkFBaUIsZ0JBQWpCOztBQUNmLG9CQUFJLEtBQUssT0FBTCxFQUFjO0FBQ2hCLDZCQUFXLFNBQVMsT0FBVCxDQUFpQixLQUFLLE9BQUwsRUFBYyxFQUEvQixDQUFYLENBRGdCO2lCQUFsQjs7OztBQU1BLG9CQUFJLEtBQUssZUFBTCxFQUFzQjtBQUN4Qiw2QkFBVyxTQUFTLE9BQVQsQ0FBaUIsS0FBSyxlQUFMLEVBQXNCLEVBQXZDLENBQVgsQ0FEd0I7aUJBQTFCOztBQUlJLDZCQUFhLEtBQUssV0FBTCxDQUFpQixRQUFqQjs7cUJBRWIsS0FBSyxlQUFMOzs7OztvQkFDRzs7Ozs7QUFDSCwwREFBd0MsZ0JBQXhDO0FBQ0EsaUNBQWUsMkJBQXNCLEtBQUssT0FBTCwyQkFBa0MsS0FBSyxlQUFMLENBQXZFO3NCQUNNLElBQUksS0FBSixnQkFBdUIsaURBQXZCOzs7aURBR0QsV0FBVyxJQUFYOzs7O3VCQUdRLGFBQUksSUFBSixDQUFTLGdCQUFUOzs7QUFB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QUFFakMsWUFBSSxNQUFNLEtBQU4sSUFBZSxJQUFJLENBQUosRUFBTyxlQUExQjs7QUFFQSxZQUFJLGVBQWUsU0FBZixFQUEwQixPQUFPLElBQVAsQ0FBOUI7T0FKRjs7QUFPQSxVQUFJLGlCQUFpQixDQUFqQixFQUFvQixPQUFPLEtBQVAsQ0FBeEI7QUFDQSxhQUFPLFlBQUMsR0FBZSxJQUFJLE1BQUosR0FBYyxJQUE5QixDQVo2Qjs7OztTQTVUbkIiLCJmaWxlIjoiZmlsZS1jaGFuZ2UtY2FjaGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQge3BmcywgcHpsaWJ9IGZyb20gJy4vcHJvbWlzZSc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHNhbml0aXplRmlsZVBhdGggZnJvbSAnLi9zYW5pdGl6ZS1wYXRocyc7XG5cbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOmZpbGUtY2hhbmdlLWNhY2hlJyk7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBjYWNoZXMgaW5mb3JtYXRpb24gYWJvdXQgZmlsZXMgYW5kIGRldGVybWluZXMgd2hldGhlciB0aGV5IGhhdmVcbiAqIGNoYW5nZWQgY29udGVudHMgb3Igbm90LiBNb3N0IGltcG9ydGFudGx5LCB0aGlzIGNsYXNzIGNhY2hlcyB0aGUgaGFzaCBvZiBzZWVuXG4gKiBmaWxlcyBzbyB0aGF0IGF0IGRldmVsb3BtZW50IHRpbWUsIHdlIGRvbid0IGhhdmUgdG8gcmVjYWxjdWxhdGUgdGhlbSBjb25zdGFudGx5LlxuICogXG4gKiBUaGlzIGNsYXNzIGlzIGFsc28gdGhlIGNvcmUgb2YgaG93IGVsZWN0cm9uLWNvbXBpbGUgcnVucyBxdWlja2x5IGluIHByb2R1Y3Rpb25cbiAqIG1vZGUgLSBhZnRlciBwcmVjb21waWxhdGlvbiwgdGhlIGNhY2hlIGlzIHNlcmlhbGl6ZWQgYWxvbmcgd2l0aCB0aGUgcmVzdCBvZiB0aGVcbiAqIGRhdGEgaW4ge0BsaW5rIENvbXBpbGVySG9zdH0sIHNvIHRoYXQgd2hlbiB3ZSBsb2FkIHRoZSBhcHAgaW4gcHJvZHVjdGlvbiBtb2RlLFxuICogd2UgZG9uJ3QgZW5kIHVwIGNhbGN1bGF0aW5nIGhhc2hlcyBvZiBmaWxlIGNvbnRlbnQgYXQgYWxsLCBvbmx5IHVzaW5nIHRoZSBjb250ZW50c1xuICogb2YgdGhpcyBjYWNoZS5cbiAqLyBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVDaGFuZ2VkQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihhcHBSb290LCBmYWlsT25DYWNoZU1pc3M9ZmFsc2UpIHtcbiAgICB0aGlzLmFwcFJvb3QgPSBzYW5pdGl6ZUZpbGVQYXRoKGFwcFJvb3QpO1xuICAgIHRoaXMuZmFpbE9uQ2FjaGVNaXNzID0gZmFpbE9uQ2FjaGVNaXNzO1xuICAgIHRoaXMuY2hhbmdlQ2FjaGUgPSB7fTtcbiAgfVxuICBcbiAgLyoqICBcbiAgICogQWxsb3dzIHlvdSB0byBjcmVhdGUgYSBGaWxlQ2hhbmdlZENhY2hlIGZyb20gc2VyaWFsaXplZCBkYXRhIHNhdmVkIGZyb20gXG4gICAqIHtAbGluayBnZXRTYXZlZERhdGF9LlxuICAgKiAgICBcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhICBTYXZlZCBkYXRhIGZyb20gZ2V0U2F2ZWREYXRhLlxuICAgKiBcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvbmUgd2hpY2ggaGFzIHlvdXIgcGFja2FnZS5qc29uKS5cbiAgICogXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGZhaWxPbkNhY2hlTWlzcyAob3B0aW9uYWwpICBJZiBUcnVlLCBjYWNoZSBtaXNzZXMgd2lsbCB0aHJvdy5cbiAgICogXG4gICAqIEByZXR1cm4ge0ZpbGVDaGFuZ2VkQ2FjaGV9XG4gICAqLyAgIFxuICBzdGF0aWMgbG9hZEZyb21EYXRhKGRhdGEsIGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcz10cnVlKSB7XG4gICAgbGV0IHJldCA9IG5ldyBGaWxlQ2hhbmdlZENhY2hlKGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcyk7XG4gICAgcmV0LmNoYW5nZUNhY2hlID0gZGF0YS5jaGFuZ2VDYWNoZTtcbiAgICByZXQub3JpZ2luYWxBcHBSb290ID0gZGF0YS5hcHBSb290O1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG5cbiAgLyoqICBcbiAgICogQWxsb3dzIHlvdSB0byBjcmVhdGUgYSBGaWxlQ2hhbmdlZENhY2hlIGZyb20gc2VyaWFsaXplZCBkYXRhIHNhdmVkIGZyb20gXG4gICAqIHtAbGluayBzYXZlfS5cbiAgICogICAgXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgU2F2ZWQgZGF0YSBmcm9tIHNhdmUuXG4gICAqIFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxuICAgKiBcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZmFpbE9uQ2FjaGVNaXNzIChvcHRpb25hbCkgIElmIFRydWUsIGNhY2hlIG1pc3NlcyB3aWxsIHRocm93LlxuICAgKiBcbiAgICogQHJldHVybiB7UHJvbWlzZTxGaWxlQ2hhbmdlZENhY2hlPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkRnJvbUZpbGUoZmlsZSwgYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzPXRydWUpIHtcbiAgICBkKGBMb2FkaW5nIGNhbm5lZCBGaWxlQ2hhbmdlZENhY2hlIGZyb20gJHtmaWxlfWApO1xuICBcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGUpO1xuICAgIHJldHVybiBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShKU09OLnBhcnNlKGF3YWl0IHB6bGliLmd1bnppcChidWYpKSwgYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzKTtcbiAgfVxuICBcbiAgXG4gIC8qKiAgXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYSBnaXZlbiBmaWxlLCBpbmNsdWRpbmcgaXRzIGhhc2guIFRoaXMgbWV0aG9kIGlzXG4gICAqIHRoZSBtYWluIG1ldGhvZCBmb3IgdGhpcyBjYWNoZS5cbiAgICogICAgXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYWJzb2x1dGVGaWxlUGF0aCAgVGhlIHBhdGggdG8gYSBmaWxlIHRvIHJldHJpZXZlIGluZm8gb24uXG4gICAqIFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG4gICAqIFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaGFzaCAgVGhlIFNIQTEgaGFzaCBvZiB0aGUgZmlsZVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWluaWZpZWQgIFRydWUgaWYgdGhlIGZpbGUgaXMgbWluaWZpZWRcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBpc0luTm9kZU1vZHVsZXMgIFRydWUgaWYgdGhlIGZpbGUgaXMgaW4gYSBsaWJyYXJ5IGRpcmVjdG9yeVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc1NvdXJjZU1hcCAgVHJ1ZSBpZiB0aGUgZmlsZSBoYXMgYSBzb3VyY2UgbWFwXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNGaWxlQmluYXJ5ICBUcnVlIGlmIHRoZSBmaWxlIGlzIG5vdCBhIHRleHQgZmlsZVxuICAgKiBAcHJvcGVydHkge0J1ZmZlcn0gYmluYXJ5RGF0YSAob3B0aW9uYWwpICBUaGUgYnVmZmVyIHRoYXQgd2FzIHJlYWQgaWYgdGhlIGZpbGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzIGJpbmFyeSBhbmQgdGhlcmUgd2FzIGEgY2FjaGUgbWlzcy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgKG9wdGlvbmFsKSAgVGhlIHN0cmluZyB0aGF0IHdhcyByZWFkIGlmIHRoZSBmaWxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyB0ZXh0IGFuZCB0aGVyZSB3YXMgYSBjYWNoZSBtaXNzXG4gICAqLyAgIFxuICBhc3luYyBnZXRIYXNoRm9yUGF0aChhYnNvbHV0ZUZpbGVQYXRoKSB7XG4gICAgbGV0IGNhY2hlS2V5ID0gc2FuaXRpemVGaWxlUGF0aChhYnNvbHV0ZUZpbGVQYXRoKTtcbiAgICBpZiAodGhpcy5hcHBSb290KSB7XG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5hcHBSb290LCAnJyk7XG4gICAgfSBcbiAgICBcbiAgICAvLyBOQjogV2UgZG8gdGhpcyBiZWNhdXNlIHgtcmVxdWlyZSB3aWxsIGluY2x1ZGUgYW4gYWJzb2x1dGUgcGF0aCBmcm9tIHRoZSBcbiAgICAvLyBvcmlnaW5hbCBidWlsdCBhcHAgYW5kIHdlIG5lZWQgdG8gc3RpbGwgZ3JvayBpdFxuICAgIGlmICh0aGlzLm9yaWdpbmFsQXBwUm9vdCkge1xuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMub3JpZ2luYWxBcHBSb290LCAnJyk7XG4gICAgfVxuICAgIFxuICAgIGxldCBjYWNoZUVudHJ5ID0gdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV07XG4gICAgXG4gICAgaWYgKHRoaXMuZmFpbE9uQ2FjaGVNaXNzKSB7XG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcbiAgICAgICAgZChgVHJpZWQgdG8gcmVhZCBmaWxlIGNhY2hlIGVudHJ5IGZvciAke2Fic29sdXRlRmlsZVBhdGh9YCk7XG4gICAgICAgIGQoYGNhY2hlS2V5OiAke2NhY2hlS2V5fSwgYXBwUm9vdDogJHt0aGlzLmFwcFJvb3R9LCBvcmlnaW5hbEFwcFJvb3Q6ICR7dGhpcy5vcmlnaW5hbEFwcFJvb3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH0gYnV0IGl0IHdhcyBub3QgcHJlY29tcGlsZWQhYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XG4gICAgfVxuICAgICAgICBcbiAgICBsZXQgc3RhdCA9IGF3YWl0IHBmcy5zdGF0KGFic29sdXRlRmlsZVBhdGgpO1xuICAgIGxldCBjdGltZSA9IHN0YXQuY3RpbWUuZ2V0VGltZSgpO1xuICAgIGxldCBzaXplID0gc3RhdC5zaXplO1xuICAgIGlmICghc3RhdCB8fCAhc3RhdC5pc0ZpbGUoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGF0ICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcbiAgICBcbiAgICBpZiAoY2FjaGVFbnRyeSkge1xuICAgICAgaWYgKGNhY2hlRW50cnkuY3RpbWUgPj0gY3RpbWUgJiYgY2FjaGVFbnRyeS5zaXplID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XG4gICAgICB9XG4gICAgICBcbiAgICAgIGQoYEludmFsaWRhdGluZyBjYWNoZSBlbnRyeTogJHtjYWNoZUVudHJ5LmN0aW1lfSA9PT0gJHtjdGltZX0gJiYgJHtjYWNoZUVudHJ5LnNpemV9ID09PSAke3NpemV9YCk7XG4gICAgICBkZWxldGUgdGhpcy5jaGFuZ2VDYWNoZS5jYWNoZUVudHJ5O1xuICAgIH1cbiAgICBcbiAgICBsZXQge2RpZ2VzdCwgc291cmNlQ29kZSwgYmluYXJ5RGF0YX0gPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUhhc2hGb3JGaWxlKGFic29sdXRlRmlsZVBhdGgpO1xuICAgIFxuICAgIGxldCBpbmZvID0ge1xuICAgICAgaGFzaDogZGlnZXN0LFxuICAgICAgaXNNaW5pZmllZDogRmlsZUNoYW5nZWRDYWNoZS5jb250ZW50c0FyZU1pbmlmaWVkKHNvdXJjZUNvZGUgfHwgJycpLFxuICAgICAgaXNJbk5vZGVNb2R1bGVzOiBGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhhYnNvbHV0ZUZpbGVQYXRoKSxcbiAgICAgIGhhc1NvdXJjZU1hcDogRmlsZUNoYW5nZWRDYWNoZS5oYXNTb3VyY2VNYXAoc291cmNlQ29kZSB8fCAnJyksXG4gICAgICBpc0ZpbGVCaW5hcnk6ICEhYmluYXJ5RGF0YVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0gPSB7IGN0aW1lLCBzaXplLCBpbmZvIH07XG4gICAgZChgQ2FjaGUgZW50cnkgZm9yICR7Y2FjaGVLZXl9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldKX1gKTtcblxuICAgIGlmIChiaW5hcnlEYXRhKSB7XG4gICAgICByZXR1cm4gXy5leHRlbmQoe2JpbmFyeURhdGF9LCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHtzb3VyY2VDb2RlfSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgLyoqICBcbiAgICogUmV0dXJucyBkYXRhIHRoYXQgY2FuIHBhc3NlZCB0byB7QGxpbmsgbG9hZEZyb21EYXRhfSB0byByZWh5ZHJhdGUgdGhpcyBjYWNoZS5cbiAgICogICAgXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovICAgXG4gIGdldFNhdmVkRGF0YSgpIHtcbiAgICByZXR1cm4geyBjaGFuZ2VDYWNoZTogdGhpcy5jaGFuZ2VDYWNoZSwgYXBwUm9vdDogdGhpcy5hcHBSb290IH07XG4gIH1cbiAgICBcbiAgLyoqICBcbiAgICogU2VyaWFsaXplcyB0aGlzIG9iamVjdCdzIGRhdGEgdG8gYSBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHNhdmUgZGF0YSB0by5cbiAgICogICAgXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IENvbXBsZXRpb24uXG4gICAqLyAgIFxuICBhc3luYyBzYXZlKGZpbGVQYXRoKSB7XG4gICAgbGV0IHRvU2F2ZSA9IHRoaXMuZ2V0U2F2ZWREYXRhKCk7XG4gICAgXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh0b1NhdmUpKSk7XG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZShmaWxlUGF0aCwgYnVmKTtcbiAgfVxuICBcbiAgYXN5bmMgY2FsY3VsYXRlSGFzaEZvckZpbGUoYWJzb2x1dGVGaWxlUGF0aCkge1xuICAgIGxldCBidWYgPSBhd2FpdCBwZnMucmVhZEZpbGUoYWJzb2x1dGVGaWxlUGF0aCk7XG4gICAgbGV0IGVuY29kaW5nID0gRmlsZUNoYW5nZWRDYWNoZS5kZXRlY3RGaWxlRW5jb2RpbmcoYnVmKTtcbiAgICBcbiAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnVmKS5kaWdlc3QoJ2hleCcpO1xuICAgICAgcmV0dXJuIHsgc291cmNlQ29kZTogbnVsbCwgZGlnZXN0LCBiaW5hcnlEYXRhOiBidWYgfTtcbiAgICB9XG4gICAgXG4gICAgbGV0IHNvdXJjZUNvZGUgPSBhd2FpdCBwZnMucmVhZEZpbGUoYWJzb2x1dGVGaWxlUGF0aCwgZW5jb2RpbmcpO1xuICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzb3VyY2VDb2RlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgXG4gICAgcmV0dXJuIHtzb3VyY2VDb2RlLCBkaWdlc3QsIGJpbmFyeURhdGE6IG51bGwgfTtcbiAgfVxuICBcbiAgZ2V0SGFzaEZvclBhdGhTeW5jKGFic29sdXRlRmlsZVBhdGgpIHtcbiAgICBsZXQgY2FjaGVLZXkgPSBzYW5pdGl6ZUZpbGVQYXRoKGFic29sdXRlRmlsZVBhdGgpO1xuICAgIGlmICh0aGlzLmFwcFJvb3QpIHtcbiAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkucmVwbGFjZSh0aGlzLmFwcFJvb3QsICcnKTtcbiAgICB9IFxuICAgIFxuICAgIC8vIE5COiBXZSBkbyB0aGlzIGJlY2F1c2UgeC1yZXF1aXJlIHdpbGwgaW5jbHVkZSBhbiBhYnNvbHV0ZSBwYXRoIGZyb20gdGhlIFxuICAgIC8vIG9yaWdpbmFsIGJ1aWx0IGFwcCBhbmQgd2UgbmVlZCB0byBzdGlsbCBncm9rIGl0XG4gICAgaWYgKHRoaXMub3JpZ2luYWxBcHBSb290KSB7XG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5vcmlnaW5hbEFwcFJvb3QsICcnKTtcbiAgICB9XG4gICAgXG4gICAgbGV0IGNhY2hlRW50cnkgPSB0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XTtcbiAgICBcbiAgICBpZiAodGhpcy5mYWlsT25DYWNoZU1pc3MpIHtcbiAgICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgICBkKGBUcmllZCB0byByZWFkIGZpbGUgY2FjaGUgZW50cnkgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcbiAgICAgICAgZChgY2FjaGVLZXk6ICR7Y2FjaGVLZXl9LCBhcHBSb290OiAke3RoaXMuYXBwUm9vdH0sIG9yaWdpbmFsQXBwUm9vdDogJHt0aGlzLm9yaWdpbmFsQXBwUm9vdH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc2tlZCBmb3IgJHthYnNvbHV0ZUZpbGVQYXRofSBidXQgaXQgd2FzIG5vdCBwcmVjb21waWxlZCFgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcbiAgICB9XG4gICAgICAgIFxuICAgIGxldCBzdGF0ID0gZnMuc3RhdFN5bmMoYWJzb2x1dGVGaWxlUGF0aCk7XG4gICAgbGV0IGN0aW1lID0gc3RhdC5jdGltZS5nZXRUaW1lKCk7XG4gICAgbGV0IHNpemUgPSBzdGF0LnNpemU7XG4gICAgaWYgKCFzdGF0IHx8ICFzdGF0LmlzRmlsZSgpKSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHN0YXQgJHthYnNvbHV0ZUZpbGVQYXRofWApO1xuICAgIFxuICAgIGlmIChjYWNoZUVudHJ5KSB7XG4gICAgICBpZiAoY2FjaGVFbnRyeS5jdGltZSA+PSBjdGltZSAmJiBjYWNoZUVudHJ5LnNpemUgPT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZChgSW52YWxpZGF0aW5nIGNhY2hlIGVudHJ5OiAke2NhY2hlRW50cnkuY3RpbWV9ID09PSAke2N0aW1lfSAmJiAke2NhY2hlRW50cnkuc2l6ZX0gPT09ICR7c2l6ZX1gKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNoYW5nZUNhY2hlLmNhY2hlRW50cnk7XG4gICAgfVxuICAgIFxuICAgIGxldCB7ZGlnZXN0LCBzb3VyY2VDb2RlLCBiaW5hcnlEYXRhfSA9IHRoaXMuY2FsY3VsYXRlSGFzaEZvckZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgpO1xuICAgIFxuICAgIGxldCBpbmZvID0ge1xuICAgICAgaGFzaDogZGlnZXN0LFxuICAgICAgaXNNaW5pZmllZDogRmlsZUNoYW5nZWRDYWNoZS5jb250ZW50c0FyZU1pbmlmaWVkKHNvdXJjZUNvZGUgfHwgJycpLFxuICAgICAgaXNJbk5vZGVNb2R1bGVzOiBGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhhYnNvbHV0ZUZpbGVQYXRoKSxcbiAgICAgIGhhc1NvdXJjZU1hcDogRmlsZUNoYW5nZWRDYWNoZS5oYXNTb3VyY2VNYXAoc291cmNlQ29kZSB8fCAnJyksXG4gICAgICBpc0ZpbGVCaW5hcnk6ICEhYmluYXJ5RGF0YVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0gPSB7IGN0aW1lLCBzaXplLCBpbmZvIH07XG4gICAgZChgQ2FjaGUgZW50cnkgZm9yICR7Y2FjaGVLZXl9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldKX1gKTtcblxuICAgIGlmIChiaW5hcnlEYXRhKSB7XG4gICAgICByZXR1cm4gXy5leHRlbmQoe2JpbmFyeURhdGF9LCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHtzb3VyY2VDb2RlfSwgaW5mbyk7XG4gICAgfVxuICB9XG4gICAgXG4gIHNhdmVTeW5jKGZpbGVQYXRoKSB7XG4gICAgbGV0IHRvU2F2ZSA9IHRoaXMuZ2V0U2F2ZWREYXRhKCk7XG5cbiAgICBsZXQgYnVmID0gemxpYi5nemlwU3luYyhuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHRvU2F2ZSkpKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBidWYpO1xuICB9XG4gICAgXG4gIGNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKSB7XG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcbiAgICBsZXQgZW5jb2RpbmcgPSBGaWxlQ2hhbmdlZENhY2hlLmRldGVjdEZpbGVFbmNvZGluZyhidWYpO1xuICAgIFxuICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShidWYpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICByZXR1cm4geyBzb3VyY2VDb2RlOiBudWxsLCBkaWdlc3QsIGJpbmFyeURhdGE6IGJ1Zn07XG4gICAgfVxuICAgIFxuICAgIGxldCBzb3VyY2VDb2RlID0gZnMucmVhZEZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgsIGVuY29kaW5nKTtcbiAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoc291cmNlQ29kZSwgJ3V0ZjgnKS5kaWdlc3QoJ2hleCcpO1xuICAgIFxuICAgIHJldHVybiB7c291cmNlQ29kZSwgZGlnZXN0LCBiaW5hcnlEYXRhOiBudWxsfTsgIFxuICB9XG4gIFxuICBcbiAgLyoqICBcbiAgICogRGV0ZXJtaW5lcyB2aWEgc29tZSBzdGF0aXN0aWNzIHdoZXRoZXIgYSBmaWxlIGlzIGxpa2VseSB0byBiZSBtaW5pZmllZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovICAgXG4gIHN0YXRpYyBjb250ZW50c0FyZU1pbmlmaWVkKHNvdXJjZSkge1xuICAgIGxldCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAxMDI0KSBsZW5ndGggPSAxMDI0O1xuXG4gICAgbGV0IG5ld2xpbmVDb3VudCA9IDA7XG5cbiAgICAvLyBSb2xsIHRocm91Z2ggdGhlIGNoYXJhY3RlcnMgYW5kIGRldGVybWluZSB0aGUgYXZlcmFnZSBsaW5lIGxlbmd0aFxuICAgIGZvcihsZXQgaT0wOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc291cmNlW2ldID09PSAnXFxuJykgbmV3bGluZUNvdW50Kys7XG4gICAgfVxuXG4gICAgLy8gTm8gTmV3bGluZXM/IEFueSBmaWxlIG90aGVyIHRoYW4gYSBzdXBlciBzbWFsbCBvbmUgaXMgbWluaWZpZWRcbiAgICBpZiAobmV3bGluZUNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gKGxlbmd0aCA+IDgwKTtcbiAgICB9XG5cbiAgICBsZXQgYXZnTGluZUxlbmd0aCA9IGxlbmd0aCAvIG5ld2xpbmVDb3VudDtcbiAgICByZXR1cm4gKGF2Z0xpbmVMZW5ndGggPiA4MCk7XG4gIH1cblxuICBcbiAgLyoqICBcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcGF0aCBpcyBpbiBub2RlX21vZHVsZXMgb3IgdGhlIEVsZWN0cm9uIGluaXQgY29kZVxuICAgKiAgICBcbiAgICogQHByaXZhdGVcbiAgICovICAgXG4gIHN0YXRpYyBpc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gISEoZmlsZVBhdGgubWF0Y2goL25vZGVfbW9kdWxlc1tcXFxcXFwvXS9pKSB8fCBmaWxlUGF0aC5tYXRjaCgvYXRvbVxcLmFzYXIvKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBmaWxlIGhhcyBhbiBpbmxpbmUgc291cmNlIG1hcFxuICAgKiAgICBcbiAgICogQHByaXZhdGVcbiAgICovICAgXG4gIHN0YXRpYyBoYXNTb3VyY2VNYXAoc291cmNlQ29kZSkge1xuICAgIHJldHVybiBzb3VyY2VDb2RlLmxhc3RJbmRleE9mKCcvLyMgc291cmNlTWFwJykgPiBzb3VyY2VDb2RlLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgfVxuICBcbiAgLyoqICBcbiAgICogRGV0ZXJtaW5lcyB0aGUgZW5jb2Rpbmcgb2YgYSBmaWxlIGZyb20gdGhlIHR3byBtb3N0IGNvbW1vbiBlbmNvZGluZ3MgYnkgdHJ5aW5nXG4gICAqIHRvIGRlY29kZSBpdCB0aGVuIGxvb2tpbmcgZm9yIGVuY29kaW5nIGVycm9yc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi8gICBcbiAgc3RhdGljIGRldGVjdEZpbGVFbmNvZGluZyhidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDEpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYnVmID0gKGJ1ZmZlci5sZW5ndGggPCA0MDk2ID8gYnVmZmVyIDogYnVmZmVyLnNsaWNlKDAsIDQwOTYpKTtcbiAgICBcbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbJ3V0ZjgnLCAndXRmMTZsZSddO1xuICAgIFxuICAgIGxldCBlbmNvZGluZyA9IF8uZmluZChcbiAgICAgIGVuY29kaW5ncywgXG4gICAgICAoeCkgPT4gIUZpbGVDaGFuZ2VkQ2FjaGUuY29udGFpbnNDb250cm9sQ2hhcmFjdGVycyhidWYudG9TdHJpbmcoeCkpKTtcbiAgICBcbiAgICByZXR1cm4gZW5jb2Rpbmc7XG4gIH1cbiAgXG4gIC8qKiAgXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBpcyBsaWtlbHkgdG8gYmUgcG9vcmx5IGVuY29kZWQgYnkgbG9va2luZyBmb3JcbiAgICogY29udHJvbCBjaGFyYWN0ZXJzIGFib3ZlIGEgY2VydGFpbiB0aHJlc2hvbGRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovICAgXG4gIHN0YXRpYyBjb250YWluc0NvbnRyb2xDaGFyYWN0ZXJzKHN0cikge1xuICAgIGxldCBjb250cm9sQ291bnQgPSAwO1xuICAgIGxldCB0aHJlc2hvbGQgPSAoc3RyLmxlbmd0aCA8IDY0ID8gMiA6IDE2KTtcbiAgICBcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoYyA9PT0gNjU1MzYgfHwgYyA8IDgpIGNvbnRyb2xDb3VudCsrO1xuICAgICAgXG4gICAgICBpZiAoY29udHJvbENvdW50ID4gdGhyZXNob2xkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbnRyb2xDb3VudCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoY29udHJvbENvdW50IC8gc3RyLmxlbmd0aCkgPCAwLjAyO1xuICB9XG59XG4iXX0=